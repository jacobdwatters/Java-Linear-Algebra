<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatrixManipulations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java-Linear-Algebra</a> &gt; <a href="index.source.html" class="el_package">linalg</a> &gt; <span class="el_source">MatrixManipulations.java</span></div><h1>MatrixManipulations.java</h1><pre class="source lang-java linenums">package linalg;

import linalg.complex_number.CNumber;
import linalg.util.LinAlgArrayUtils;
import linalg.util.Parser;

/**
 * This interface provides several methods useful for matrix manipulations and is
 * Implemented by the Matrix class.
 * 
 * @author Jacob Watters
 */
// TODO: Many methods in this class should probably manipulate the instance object and have void return.
 interface MatrixManipulations {
	
	
	 default Matrix reshape(String newShape) {
<span class="nc" id="L18">		int[] dimensions = Parser.parseShape(newShape);</span>
<span class="nc" id="L19">		int 	newM = dimensions[0],</span>
<span class="nc" id="L20">				newN = dimensions[1];</span>
		
<span class="nc" id="L22">		return this.reshape(newM, newN);</span>
	}
	
	
	 default Matrix reshape(int newM, int newN) {
<span class="nc" id="L27">		Matrix A = ((Matrix) this).flatten();</span>
<span class="nc" id="L28">		Matrix reshape = new Matrix(newM, newN);</span>
<span class="nc" id="L29">		int aj=0;</span>

<span class="nc bnc" id="L31" title="All 2 branches missed.">		if(newM*newN != A.m*A.n) {</span>
<span class="nc" id="L32">			throw new IllegalArgumentException(&quot;Can not reshape matrix of shape &quot; + A.shape + &quot; to &quot; + newM + &quot;x&quot; + newN + &quot;.&quot;);</span>
		}


<span class="nc bnc" id="L36" title="All 2 branches missed.">		for(int i=0; i&lt;reshape.m; i++) {</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">			for(int j=0; j&lt;reshape.n; j++) {</span>
<span class="nc" id="L38">				reshape.entries[i][j] = new CNumber(A.entries[0][aj]);</span>
<span class="nc" id="L39">				aj++;</span>
			}
		}
		
				
<span class="nc" id="L44">		return reshape;</span>
	}
	
	
	/**
	 * Flattens an &lt;code&gt;MxN&lt;/code&gt; matrix to a 1x(m*n) matrix.
	 * Each row of the Matrix is appended to the end
	 * of the first row of the Matrix in order.
	 * 
	 * @return 
	 */
	 default Matrix flatten() {
<span class="nc" id="L56">		Matrix A = (Matrix) this,</span>
				flat;
<span class="nc" id="L58">		int count = 0;</span>

<span class="nc" id="L60">		CNumber[][] flat_A = new CNumber[1][A.m*A.n];</span>
		
<span class="nc bnc" id="L62" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">			for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L64">				flat_A[0][count] = A.entries[i][j];</span>
<span class="nc" id="L65">				count++;</span>
			}
		}
		
<span class="nc" id="L69">		flat = new Matrix(flat_A);</span>
		
<span class="nc" id="L71">		return flat;</span>
	}
	
	
	/**
	 * Flattens an &lt;code&gt;MxN&lt;/code&gt; matrix to a 1x(m*n) or (m*n)x1 matrix depending on axis.
	 *
	 * @param axis - axis along which to flatten
	 * @return 
	 */
	 default Matrix flatten(int axis) {
<span class="nc" id="L82">		Matrix A = (Matrix) this,</span>
				flat;
		
<span class="nc bnc" id="L85" title="All 2 branches missed.">		if(axis == 0) {</span>
<span class="nc" id="L86">			flat = A.flatten();</span>
		}
<span class="nc bnc" id="L88" title="All 2 branches missed.">		else if(axis == 1) {	</span>
<span class="nc" id="L89">			int count = 0;</span>

<span class="nc" id="L91">			CNumber[][] flat_A = new CNumber[A.m*A.n][1];</span>
			
<span class="nc bnc" id="L93" title="All 2 branches missed.">			for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">				for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L95">					flat_A[count][0] = A.entries[i][j];</span>
<span class="nc" id="L96">					count++;</span>
				}
			}
			
<span class="nc" id="L100">			flat = new Matrix(flat_A);</span>
<span class="nc" id="L101">		}</span>
		else {
<span class="nc" id="L103">			throw new IllegalArgumentException(&quot;axis must be 0 or 1 but got &quot; + axis);</span>
		}
		
<span class="nc" id="L106">		return flat;</span>
	}


	/**
	 * Extends a row or column vector to form a matrix. That is, for a row vector,
	 *
	 * @param n Number of times to make the extension. That is, for a row vector with m entries, a matrix of shape
	 *          n-by-m will be formed. For a column vector with m entries, a matrix of shape m-by-n will be formed.
	 *
	 * @return The extended matrix formed from the vector.
	 * @throws IllegalCallerException if the caller is not a {@link Vector}
	 */
	default Matrix extend(int n) {

<span class="nc bnc" id="L121" title="All 2 branches missed.">		if(!(this instanceof Vector)) {</span>
<span class="nc" id="L122">			throw new IllegalCallerException(&quot;This matrix is not a Vector.&quot;);</span>
		}

<span class="nc" id="L125">		Vector v = (Vector) this;</span>
		Matrix extended;

<span class="nc bnc" id="L128" title="All 2 branches missed.">		if(v.vectorType() == Vector.COLUMN_VECTOR) {</span>
<span class="nc" id="L129">			extended = new Matrix(v.numRows(), n);</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">			for(int i=0; i&lt;extended.numRows(); i++) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">				for(int j=0; j&lt;extended.numCols(); j++) {</span>
<span class="nc" id="L133">					extended.entries[i][j] = v.get(i, 0);</span>
				}
			}

		} else {
<span class="nc" id="L138">			extended = new Matrix(n, v.numCols());</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">			for(int i=0; i&lt;n; i++) {</span>
<span class="nc" id="L141">				extended.entries[i] = v.getEntries();</span>
			}
		}

<span class="nc" id="L145">		return extended;</span>
	}


	/**
	 * Copies values from array into matrix. The given array must have the same dimensions
	 * as the matrix object. This will replace any current values in the matrix.
	 * 
	 *  @param values - Values to copy into array
	 */
	 default void setValues(CNumber[][] values) {
<span class="nc" id="L156">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L158" title="All 4 branches missed.">		if(values.length != A.entries.length || values[0].length != A.entries[0].length) {</span>
<span class="nc" id="L159">			throw new IllegalArgumentException(&quot;Expecting array with shape &quot; + A.shape + </span>
					&quot; but got array with shape &quot; + values.length + &quot;x&quot; + values[0].length + &quot;.&quot;);
		}
		
<span class="nc" id="L163">		A.entries = values;</span>
<span class="nc" id="L164">	}</span>
	
	
	/**
	 * Copies values from array into matrix. The given array must have the same dimensions
	 * as the matrix object. A will replace any current values in the matrix.
	 * 
	 *  @param values - Values to copy into array
	 */
	 default void setValues(double[][] values) {
<span class="nc" id="L174">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L176" title="All 4 branches missed.">		if(values.length != A.entries.length || values[0].length != A.entries[0].length) {</span>
<span class="nc" id="L177">			throw new IllegalArgumentException(&quot;Expecting array with shape &quot; + A.shape + </span>
					&quot; but got array with shape &quot; + values.length + &quot;x&quot; + values[0].length + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L181" title="All 2 branches missed.">		for(int i = 0; i &lt; A.entries.length; i++) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">			for(int j = 0; j &lt; A.entries[0].length; j++) {</span>
<span class="nc" id="L183">				A.entries[i][j] = new CNumber(values[i][j]);</span>
			}
		}
<span class="nc" id="L186">	}</span>
	
	
	/**
	 * Sets specified element in matrix to value. A will replace the current value
	 * at that index.
	 *
	 * @param value - value to insert into matrix
	 * @param row - row to insert value
	 * @param col - column to insert value
	 */
	 default void set(CNumber value, int row, int col) {
<span class="nc" id="L198">		Matrix A = (Matrix) this;</span>
		
<span class="nc" id="L200">		A.entries[row][col] = value;</span>
<span class="nc" id="L201">	}</span>
	
	
	/**
	 * Sets specified element in matrix to value. A will replace the current value
	 * at that index.
	 *
	 * @param value - value to insert into matrix
	 * @param row - row index to insert value
	 * @param col - column index to insert value
	 */
	 default void set(double value, int row, int col) {
<span class="nc" id="L213">		Matrix A = (Matrix) this;</span>
		
<span class="nc" id="L215">		A.entries[row][col] = new CNumber(value);</span>
<span class="nc" id="L216">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed column vector.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see &lt;br&gt;
	 * {@link #setCol(CNumber[], int) setCol(CNumber[] col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(double[], int) setCol(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the vector is not a column vector or if the vector and matrix do not
	 * 	have the same number of rows.
	 * @param col - Column vector containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(Vector col, int colIndex) {
<span class="nc" id="L232">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L234" title="All 2 branches missed.">		if(col.vectorType() != Vector.COLUMN_VECTOR) {</span>
<span class="nc" id="L235">			throw new IllegalArgumentException(&quot;Vector must be column vector.&quot;); // TODO: Add vectorTypeAsString();</span>
		}
<span class="nc bnc" id="L237" title="All 2 branches missed.">		if(col.m != A.m) {</span>
<span class="nc" id="L238">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with a vector of shape &quot; + col.shape);</span>
		}
		
<span class="nc bnc" id="L241" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L242">			A.entries[i][colIndex] = col.get(i, 0);</span>
		}
<span class="nc" id="L244">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setCol(Vector, int) setCol(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(double[], int) setCol(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of rows in the matrix.
	 * @param col - array containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(CNumber[] col, int colIndex) {
<span class="nc" id="L259">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if(col.length != A.m) {</span>
<span class="nc" id="L262">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + col.length);</span>
		}
		
<span class="nc bnc" id="L265" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L266">			A.entries[i][colIndex] = new CNumber(col[i]);</span>
		}
<span class="nc" id="L268">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed array.
	 * Also see&lt;br&gt;
	 * {@link #setCol(Vector, int) setCol(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(CNumber[], int) setCol(CNumber[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of rows in the matrix.
	 * @param col - array containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(double[] col, int colIndex) {
<span class="nc" id="L282">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L284" title="All 2 branches missed.">		if(col.length != A.m) {</span>
<span class="nc" id="L285">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + col.length);</span>
		}
		
<span class="nc bnc" id="L288" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L289">			A.entries[i][colIndex] = new CNumber(col[i]);</span>
		}
<span class="nc" id="L291">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed row vector.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see &lt;br&gt;
	 * {@link #setRow(CNumber[], int) setRow(CNumber[] col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(double[], int) setRow(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the vector is not a row vector or if the vector and matrix do not
	 * 	have the same number of columns.
	 * @param row - row vector containing the new entries for the specified column.
	 * @param rowIndex - Index of new row to set. 
	 */
	 default void setRow(Vector row, int rowIndex) {
<span class="nc" id="L307">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L309" title="All 2 branches missed.">		if(row.vectorType() != Vector.ROW_VECTOR) {</span>
<span class="nc" id="L310">			throw new IllegalArgumentException(&quot;Vector must be row vector.&quot;); // TODO: Add vectorTypeAsString();</span>
		}
<span class="nc bnc" id="L312" title="All 2 branches missed.">		if(row.n != A.n) {</span>
<span class="nc" id="L313">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with a vector of shape &quot; + row.shape);</span>
		}
		
<span class="nc bnc" id="L316" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L317">			A.entries[rowIndex][i] = row.get(0, i);</span>
		}
<span class="nc" id="L319">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setRow(Vector, int) setRow(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(double[], int) setRow(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of columns in the matrix.
	 * @param row - array containing the new entries for the specified column.
	 * @param rowIndex - Index of new column to set. 
	 */
	 default void setRow(CNumber[] row, int rowIndex) {
<span class="nc" id="L334">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L336" title="All 2 branches missed.">		if(row.length != A.n) {</span>
<span class="nc" id="L337">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + row.length);</span>
		}
		
<span class="nc bnc" id="L340" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L341">			A.entries[rowIndex][i] = new CNumber(row[i]);</span>
		}
<span class="nc" id="L343">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setRow(Vector, int) setRow(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(CNumber[], int) setRow(CNumber[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of columns in the matrix.
	 * @param row - array containing the new entries for the specified column.
	 * @param rowIndex - Index of new column to set. 
	 */
	 default void setRow(double[] row, int rowIndex) {
<span class="nc" id="L358">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L360" title="All 2 branches missed.">		if(row.length != A.n) {</span>
<span class="nc" id="L361">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + row.length);</span>
		}
		
<span class="nc bnc" id="L364" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L365">			A.entries[rowIndex][i] = new CNumber(row[i]);</span>
		}
<span class="nc" id="L367">	}</span>
	
	
	/**
	 * Creates a copy of this matrix and sets a specified slice of the copy to the values stored in the &lt;code&gt;values&lt;/code&gt; matrix. Together
	 * the parameters &lt;code&gt;rowStart&lt;/code&gt; and &lt;code&gt;colStart&lt;/code&gt; define the upper left corner of the 
	 * slice to set.&lt;br&gt;&lt;br&gt;
	 * 
	 * If the values matrix does not fit within this matrix, an error will be thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * If want to adjust this matrix instance directly see {@link #setSlice(int, int, Matrix) setSlice(Matrix values, int rowStart, int colStart)}
	 * 
	 * @return
	 */
	 default Matrix setSliceCopy(int rowStart, int colStart, Matrix values) {
<span class="nc" id="L382">		Matrix A = ((Matrix) this).copy();</span>
		
<span class="nc bnc" id="L384" title="All 4 branches missed.">		if(values.m + rowStart &gt; A.m || values.n + colStart &gt; A.n) {</span>
<span class="nc" id="L385">			throw new IllegalArgumentException(&quot;Values do not fit in matrix. Attempting to set values of shape &quot; + values.shape +</span>
					&quot; with offset of (&quot; + rowStart + &quot;, &quot; + colStart + &quot;) in a matrix of shape &quot; + A.shape + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L389" title="All 2 branches missed.">		for(int i=rowStart; i&lt;values.m + rowStart; i++) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">			for(int j=colStart; j&lt;values.n + colStart; j++) {</span>
<span class="nc" id="L391">				A.entries[i][j] = values.entries[i-rowStart][j-colStart];</span>
			}
		}
		
<span class="nc" id="L395">		return A;</span>
	}
	
	
	/**
	 * Sets a specified slice of this matrix to the values stored in the &lt;code&gt;values&lt;/code&gt; matrix. Together
	 * the parameters &lt;code&gt;rowStart&lt;/code&gt; and &lt;code&gt;colStart&lt;/code&gt; define the upper left corner of the 
	 * slice to set.&lt;br&gt;&lt;br&gt;
	 * 
	 * If the values matrix does not fit within this matrix, an error will be thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * If you do not want to adjust this matrix instance see {@link #setSliceCopy(int, int, Matrix) setSliceCopy(Matrix values, int rowStart, int colStart)}
	 * @param rowStart - Row on original matrix to place top row of values matrix
	 * @param colStart - Column on original matrix to place left-most column of values matrix
	 * @param values - New values to set within specified slice.
	 */
	 default void setSlice(int rowStart, int colStart, Matrix values) {
<span class="nc" id="L412">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L414" title="All 4 branches missed.">		if(values.m + rowStart &gt; A.m || values.n + colStart &gt; A.n) {</span>
<span class="nc" id="L415">			throw new IllegalArgumentException(&quot;Values do not fit in matrix. Attempting to set values of shape &quot; + values.shape +</span>
					&quot; with offset of (&quot; + rowStart + &quot;, &quot; + colStart + &quot;) in a matrix of shape &quot; + A.shape + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L419" title="All 2 branches missed.">		for(int i=rowStart; i&lt;values.m + rowStart; i++) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">			for(int j=colStart; j&lt;values.n + colStart; j++) {</span>
<span class="nc" id="L421">				A.entries[i][j] = values.entries[i-rowStart][j-colStart];</span>
			}
		}
<span class="nc" id="L424">	}</span>
	
	
	/**
	 * Removes specified single row from matrix.
	 * 
	 * To remove more than one row at a time
	 * see {@link #removeRows(int...) removeRows(int... rowIndices)}.
	 * 
	 * @param rowIndex - Index of row to remove.
	 * @return Matrix with the specified row removed.
	 */
	 default Matrix removeRow(int rowIndex) {
<span class="nc" id="L437">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L438">		return A.removeRows(rowIndex);</span>
	}
	
	
	/**
	 * Removes specified rows from matrix. If k row indices are specified for 
	 * a mxn matrix, the resulting matrix will have shape (m-k)xn. 
	 * 
	 * Also see {@link #removeRow(int) removeRow(int rowIndex)}.
	 * 
	 * @param rowIndices - list of row indices to remove from matrix.
	 * @return Matrix with specified rows removed
	 */
	 default Matrix removeRows(int... rowIndices) {
<span class="nc" id="L452">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L453">		Matrix result = new Matrix(A.m-(rowIndices.length), A.n);</span>
		
<span class="nc" id="L455">		int newi = 0;</span>
		
<span class="nc bnc" id="L457" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">			if(!LinAlgArrayUtils.contains(rowIndices, i)) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">				for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L460">					result.entries[newi][j] = A.entries[i][j];</span>
				}
<span class="nc" id="L462">				newi++;</span>
			}
		}
		
<span class="nc" id="L466">		return result;</span>
	}
	
	
	/**
	 * Removes specified single column from matrix.
	 * 
	 * To remove more than one column at a time
	 * see {@link #removeCols(int...) removeCols(int... colIndices)}.
	 * 
	 * @param colIndex - Index of column to remove.
	 * @return Matrix with the specified column removed.
	 */
	 default Matrix removeCol(int colIndex) {
<span class="nc" id="L480">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L481">		return A.removeCols(colIndex);</span>
	}
	
	
	/**
	 * Removes specified columns from matrix. If k column indices are specified for 
	 * a mxn matrix, the resulting matrix will have shape m-by-(n-k).
	 *
	 * Also see {@link #removeCol(int) removeCol(int colIndex)}
	 * 
	 * @param colIndices - list of column indices to remove from matrix.
	 * @return Matrix with specified columns removed
	 */
	 default Matrix removeCols(int... colIndices) {
<span class="nc" id="L495">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L496">		Matrix result = new Matrix(A.m, A.n-(colIndices.length));</span>
		
<span class="nc" id="L498">		int newj = 0;</span>
		
<span class="nc bnc" id="L500" title="All 2 branches missed.">		for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">			if(!LinAlgArrayUtils.contains(colIndices, j)) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">				for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc" id="L503">					result.entries[i][newj] = A.entries[i][j];</span>
				}
<span class="nc" id="L505">				newj++;</span>
			}
		}
		
<span class="nc" id="L509">		return result;</span>
	}
	
	
	/**
	 * Generates lower triangle of Matrix. That is, all values above the middle
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #tril(int) tril(int k)}&lt;/code&gt;
	 * 
	 * @return Lower triangle of Matrix.
	 */
	 default Matrix tril() {
<span class="nc" id="L522">		return this.tril(0);</span>
	}
	
	
	/**
	 * Generates lower triangle of Matrix. That is, all values above the kth
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #tril(int) tril()}&lt;/code&gt;
	 * 
	 * @param k - diagonal above which to zero. k=0 whould be middile diagonal, k=-1 would be 
	 * 	the diagonal to the left of the middle diagonal, and k=1 would be the diagonal to the right
	 * 	of the middle diagonal.
	 * @return Lower triangle of Matrix.
	 */
	 default Matrix tril(int k) {
<span class="nc" id="L538">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L539">		Matrix lower = Matrix.zeros(A.m, A.n);</span>
		
<span class="nc bnc" id="L541" title="All 2 branches missed.">		for(int i = 0; i &lt; lower.m; i++) {</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">			for(int j = 0; j&lt;=(i+k) &amp;&amp; j &lt; lower.n; j++) {</span>
<span class="nc" id="L543">				lower.entries[i][j] = A.entries[i][j];</span>
			}
		}
		
<span class="nc" id="L547">		return lower;</span>
	}
	
	
	/**
	 * Generates upper triangle of Matrix. That is, all values above the middle
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #triu(int) triu(int k)}&lt;/code&gt;
	 * 
	 * @return upper triangle of Matrix.
	 */
	 default Matrix triu() {
<span class="nc" id="L560">		return this.triu(0);</span>
	}
	
	
	/**
	 * Generates upper triangle of Matrix. That is, all values below the kth
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #triu(int) triu()}&lt;/code&gt;
	 * 
	 * @param k - diagonal above which to zero. k=0 would be middle diagonal, k=-1 would be 
	 * 	the diagonal to the left of the middle diagonal, and k=1 would be the diagonal to the right
	 * 	of the middle diagonal.
	 * @return upper triangle of Matrix.
	 */
	 default Matrix triu(int k) {
<span class="nc" id="L576">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L577">		Matrix upper = Matrix.zeros(A.m, A.n);</span>
<span class="nc" id="L578">		int jstart = 0;</span>
		
		
<span class="nc bnc" id="L581" title="All 2 branches missed.">		for(int i = 0; i &lt; upper.m; i++) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if(i+k &lt;= 0) {jstart = 0;}</span>
<span class="nc" id="L583">			else {jstart = i+k;}</span>
			
<span class="nc bnc" id="L585" title="All 4 branches missed.">			for(int j = jstart; j-k&gt;=(i) &amp;&amp; j &lt; upper.n; j++) {</span>
<span class="nc" id="L586">				upper.entries[i][j] = A.entries[i][j];</span>
			}
		}
		
<span class="nc" id="L590">		return upper;</span>
	}
	
	
	/**
	 * Extracts diagonal elements from matrix.
	 * 
	 * @return Returns an equivalently sized matrix containing only the diagonal elements of this matrix.
	 */
	 default Matrix diag() {
<span class="nc" id="L600">		return this.triu(0).tril(0);</span>
	}
	
	
	/**
	 * Sets elements from list as diagonal elements of a zero matrix.
	 * 
	 * @return Returns an equivalently sized matrix containing only the diagonal elements of this matrix.
	 */
	 static Matrix toDiag(CNumber... entries) {
<span class="nc" id="L610">		Matrix A = new Matrix(entries.length);</span>
		
<span class="nc bnc" id="L612" title="All 2 branches missed.">		for(int i=0; i&lt;entries.length; i++) {</span>
<span class="nc" id="L613">			A.entries[i][i] = entries[i];</span>
		}
		
<span class="nc" id="L616">		return A;</span>
	}
	
	
	/**
	 * Extracts diagonal elements form matrix and stores in vector.
	 * 
	 * @return Column vector containing diagonal elements of this matrix.
	 */
	 default Vector diagAsVector() {
<span class="nc" id="L626">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L627">		Vector diag = new Vector(Math.min(A.m, A.n));</span>
		
<span class="nc bnc" id="L629" title="All 2 branches missed.">		for(int i=0; i&lt;diag.m; i++) {</span>
<span class="nc" id="L630">			diag.entries[i][0] = A.entries[i][i];</span>
		}
		
<span class="nc" id="L633">		return diag;</span>
	}
	
	
	/**
	 * Converts a matrix similar to this matrix that is in upper Hessenburg form. A matrix is in upper Hessenburg form if all entries below the first subdiagonal are
	 * zero. Two n-by-n matrices A and B are similar if there exists an invertible n-by-n matrix P, such that B=P&lt;sup&gt;-1&lt;/sup&gt;AP. Similar matrices share many 
	 * properties including the same eigenvalues.
	 * 
	 * @return A matrix similar to this matrix which is in upper Hessenburg form.
	 */
	 default Matrix hessu() {
<span class="nc" id="L645">		Matrix H = ((Matrix) this).copy();</span>
<span class="nc" id="L646">		Matrix x, v = new Matrix(H.m, H.m);</span>
<span class="nc" id="L647">		CNumber two = new CNumber(2), eps = new CNumber(Float.MIN_VALUE);</span>
		
<span class="nc bnc" id="L649" title="All 2 branches missed.">		if(!H.isSquare()) {</span>
<span class="nc" id="L650">			throw new IllegalArgumentException(&quot;Matrix must be square but got shape &quot; + H.shape);</span>
		}
		
		
<span class="nc bnc" id="L654" title="All 2 branches missed.">		for(int k=0; k&lt;H.m-2; k++) {	</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			if(!H.getSlice(k+1, H.m, k, k+1).equalTo(new Matrix(H.m-(k+1), 1))) { // Then we need a Householder reflector. Otherwise, the column is already in the correct form so we don't need to apply a reflector.</span>
<span class="nc" id="L656">				x = H.getSlice(k+1, H.m, k, k+1);</span>
				
<span class="nc" id="L658">				v.setSlice(0, k, 	</span>
<span class="nc" id="L659">						Matrix.I(H.m-(k+1), 1).scalMult(</span>
<span class="nc" id="L660">						CNumber.multiply(</span>
<span class="nc" id="L661">							CNumber.addInv(CNumber.sign(CNumber.add(x.entries[0][0], eps))), </span>
<span class="nc" id="L662">							x.norm()</span>
<span class="nc" id="L663">						)).sub(x)</span>
				);
				
<span class="nc" id="L666">				v.setSlice(0, k, v.getSlice(0, H.m-(k+1), k, k+1).scalDiv(v.getSlice(0, H.m-(k+1), k, k+1).norm()));</span>
				
<span class="nc" id="L668">				H.setSlice(k+1, k, </span>
<span class="nc" id="L669">						H.getSlice(k+1, H.m, k, H.m).sub(v.getSlice(0, H.m-(k+1), k, k+1).mult(</span>
<span class="nc" id="L670">						v.getSlice(0, H.m-(k+1), k, k+1).H().mult(H.getSlice(k+1, H.m, k, H.m))).scalMult(two))</span>
				);
				
<span class="nc" id="L673">				H.setSlice(0, k+1, </span>
<span class="nc" id="L674">						H.getSlice(0, H.m, k+1, H.m).sub(H.getSlice(0, H.m, k+1, H.m).mult(</span>
<span class="nc" id="L675">						v.getSlice(0, H.m-(k+1), k, k+1)).mult(v.getSlice(0, H.m-(k+1), k, k+1).H()).scalMult(two))</span>
				);
			}
		}
		
<span class="nc" id="L680">		H.roundToZero(10);</span>
		
<span class="nc" id="L682">		return H;</span>
	}
	
	
	/**
	 * Converts a matrix similar to this matrix that is in upper Hessenburg form. A matrix is in upper Hessenburg form if all entries below the first subdiagonal are
	 * zero. Two n-by-n matrices A and B are similar if there exists an invertible n-by-n matrix P, such that B=P&lt;sup&gt;-1&lt;/sup&gt;AP. Similar matrices share many 
	 * properties including the same eigenvalues.
	 * 
	 * @return A matrix similar to this matrix which is in upper Hessenburg form.
	 */
	 default Matrix[] hessuV() {
<span class="nc" id="L694">		Matrix H = ((Matrix) this).copy();</span>
<span class="nc" id="L695">		Matrix x, v = new Matrix(H.m, H.m);</span>
<span class="nc" id="L696">		CNumber two = new CNumber(2), eps = new CNumber(Float.MIN_VALUE);</span>
<span class="nc" id="L697">		Matrix[] result = new Matrix[2];</span>
		
<span class="nc bnc" id="L699" title="All 2 branches missed.">		if(!H.isSquare()) {</span>
<span class="nc" id="L700">			throw new IllegalArgumentException(&quot;Matrix must be square but got shape &quot; + H.shape);</span>
		}
		
		
<span class="nc bnc" id="L704" title="All 2 branches missed.">		for(int k=0; k&lt;H.m-2; k++) {	</span>
<span class="nc" id="L705">			x = H.getSlice(k+1, H.m, k, k+1);</span>
			
<span class="nc" id="L707">			v.setSlice(0, k, 	</span>
<span class="nc" id="L708">					Matrix.I(H.m-(k+1), 1).scalMult(</span>
<span class="nc" id="L709">					CNumber.multiply(</span>
<span class="nc" id="L710">						CNumber.addInv(CNumber.sign(CNumber.add(x.entries[0][0], eps))), </span>
<span class="nc" id="L711">						x.norm()</span>
<span class="nc" id="L712">					)).sub(x)</span>
			);
			
<span class="nc" id="L715">			v.setSlice(0, k, v.getSlice(0, H.m-(k+1), k, k+1).scalDiv(v.getSlice(0, H.m-(k+1), k, k+1).norm()));</span>
			
<span class="nc" id="L717">			H.setSlice(k+1, k, </span>
<span class="nc" id="L718">					H.getSlice(k+1, H.m, k, H.m).sub(v.getSlice(0, H.m-(k+1), k, k+1).mult(</span>
<span class="nc" id="L719">					v.getSlice(0, H.m-(k+1), k, k+1).H().mult(H.getSlice(k+1, H.m, k, H.m))).scalMult(two))</span>
			);
			
<span class="nc" id="L722">			H.setSlice(0, k+1, </span>
<span class="nc" id="L723">					H.getSlice(0, H.m, k+1, H.m).sub(H.getSlice(0, H.m, k+1, H.m).mult(</span>
<span class="nc" id="L724">					v.getSlice(0, H.m-(k+1), k, k+1)).mult(v.getSlice(0, H.m-(k+1), k, k+1).H()).scalMult(two))</span>
			);
		}
		
<span class="nc" id="L728">		H.roundToZero(10);</span>
		
<span class="nc" id="L730">		result[0] = H;</span>
<span class="nc" id="L731">		result[1] = v;</span>
		
<span class="nc" id="L733">		return result;</span>
	}
	
	
	/**
	 * Swaps two rows in a matrix.
	 * 
	 * @param rowIndex1 - Index of first row to be swapped.
	 * @param rowIndex2 - Index of second row to be swapped.
	 * @return Matrix with specified rows swapped.
	 */
	 default Matrix swapRows(int rowIndex1, int rowIndex2) {
<span class="nc" id="L745">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L746">		Matrix result = A.copy();</span>
		
<span class="nc" id="L748">		CNumber[] row1 = A.entries[rowIndex1];</span>
<span class="nc" id="L749">		CNumber[] row2 = A.entries[rowIndex2];</span>
		
<span class="nc" id="L751">		result.entries[rowIndex1] = row2;</span>
<span class="nc" id="L752">		result.entries[rowIndex2] = row1;</span>
		
<span class="nc" id="L754">		return result;</span>
	}
	
	
	/**
	 * Swaps two columns in a matrix.
	 * 
	 * @param colIndex1 - Index of first column to be swapped.
	 * @param colIndex2 - Index of second column to be swapped.
	 * @return Matrix with specified columns swapped.
	 */
	 default Matrix swapCols(int colIndex1, int colIndex2) {
<span class="nc" id="L766">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L767">		Matrix result = A.copy();</span>
		
<span class="nc" id="L769">		CNumber[] col1 = A.getCol(colIndex1);</span>
<span class="nc" id="L770">		CNumber[] col2 = A.getCol(colIndex2);</span>
		
<span class="nc bnc" id="L772" title="All 2 branches missed.">		for(int i = 0; i&lt;A.m; i++) {</span>
<span class="nc" id="L773">			result.entries[i][colIndex1] = col2[i];</span>
<span class="nc" id="L774">			result.entries[i][colIndex2] = col1[i];</span>
		}
		
<span class="nc" id="L777">		return result;</span>
	}
	
	
	/**
	 * Multiplies a specified row by a constant value.
	 * 
	 * @param factor - number to multiply row by.
	 * @return Matrix with specified row multiplied by the factor.
	 */
	 default Matrix multRow(int rowIndex, CNumber factor) {
<span class="nc" id="L788">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L789">		Matrix result = new Matrix(A.m, A.n);</span>
		
<span class="nc bnc" id="L791" title="All 2 branches missed.">		for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L792">			result.entries[rowIndex][j] = CNumber.multiply(A.entries[rowIndex][j], factor); </span>
		}
		
<span class="nc" id="L795">		return result;</span>
	}

	
	/**
	 * Multiplies a specified row by a constant value.
	 * 
	 * @param factor - number to multiply row by.
	 * @return Matrix with specified row multiplied by the factor
	 */
	 default Matrix multRow(int rowIndex, double factor) {
<span class="nc" id="L806">		return multRow(rowIndex, new CNumber(factor));</span>
	}
	
	
	/**
	 * Divides a specified row by a constant value.
	 * 
	 * @param divisor - number to divide row by.
	 * @return Matrix with specified row divided by the divisor.
	 */
	 default Matrix divRow(int rowIndex, CNumber divisor) {
<span class="nc" id="L817">		return multRow(rowIndex, CNumber.inv(divisor));</span>
	}
	
	
	/**
	 * Divides a specified row by a constant value.
	 * 
	 * @param divisor - number to divide row by.
	 * @return Matrix with specified row divided by the divisor.
	 */
	 default Matrix divRow(int rowIndex, double divisor) {
<span class="nc" id="L828">		return multRow(rowIndex, 1 / divisor);</span>
	}
	
	
	/**
	 * If possible, converts matrix to a Vector object.&lt;br&gt;&lt;br&gt;
	 * A matrix will be converted to a row vector if it contains only a single row. &lt;br&gt;
	 * A matrix will be converted to a column vector if it contains only a single column. &lt;br&gt;
	 * If a matrix contains only one row and one column or is empty, then it will be converted to a column vector by default.&lt;br&gt;
	 * 
	 * @return Vector equivalent of matrix.
	 */
	 default Vector toVector() {
<span class="nc" id="L841">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L842">		Vector result = null;</span>
		
<span class="nc bnc" id="L844" title="All 4 branches missed.">		if(!A.isVector() &amp;&amp; !A.isEmpty()) {</span>
<span class="nc" id="L845">			throw new IllegalArgumentException(&quot;Can not convert matrix of shape &quot; + A.shape + &quot; to a vector.&quot;);</span>
		} else {
<span class="nc" id="L847">			int vectorType = A.vectorType();</span>
			
			
<span class="nc bnc" id="L850" title="All 2 branches missed.">			if(A.isEmpty()) {</span>
<span class="nc" id="L851">				result = new Vector();</span>
			}
			else { // 1-by-1 matrix or empty matrix will default to a column vector.
<span class="nc bnc" id="L854" title="All 2 branches missed.">				if(vectorType == 3) {</span>
<span class="nc" id="L855">					vectorType = Vector.COLUMN_VECTOR;</span>
				}
				
<span class="nc" id="L858">				result = new Vector(LinAlgArrayUtils.flatten(A.entries), vectorType);</span>
			}
		}
		
<span class="nc" id="L862">		return result;</span>
	}
	
	
	/**
	 * Rounds all entries of a matrix. If entry is complex, 
	 * both the real and imaginary part will be rounded.
	 *
	 * @param decimals - Number of decimals to round number to.
	 * @return Returns copy of Matrix &lt;code&gt;A&lt;/code&gt; with entries rounded to 
	 * 		Specified number of decimal places.  
	 */
	 default Matrix round(int decimals) {
<span class="nc" id="L875">		Matrix rounded = new Matrix((Matrix) this);</span>
		
<span class="nc bnc" id="L877" title="All 2 branches missed.">		for(int i=0; i&lt;rounded.m; i++) {</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">			for(int j=0; j&lt;rounded.n; j++) {</span>
<span class="nc" id="L879">				rounded.entries[i][j] = CNumber.round(rounded.entries[i][j], decimals);</span>
			}
		}
		
<span class="nc" id="L883">		return rounded;</span>
	}
	
	
	/**
	 * Rounds values in this matrix within a specified number of decimals of zero to zero.
	 * 
	 * @param decimals - Number of decimals 
	 */
	 default void roundToZero(int decimals) {
<span class="nc" id="L893">		double tolerance = 0.5*Math.pow(10, -decimals);</span>
<span class="nc" id="L894">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L896" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">				if(Math.abs(A.entries[i][j].mag()) &lt; tolerance) {</span>
<span class="nc" id="L899">					A.entries[i][j] = CNumber.ZERO;</span>
				}
			}
		}
<span class="nc" id="L903">	}</span>


	 public static void main(String[] args) {

<span class="nc" id="L908">		double[] val = {1, 2, 3, 4};</span>
<span class="nc" id="L909">		Vector v = new Vector(val, 1);</span>

<span class="nc" id="L911">		Matrix.println(v.extend(4));</span>
<span class="nc" id="L912">	}</span>
}









</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>