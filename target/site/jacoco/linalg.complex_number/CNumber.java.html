<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CNumber.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java-Linear-Algebra</a> &gt; <a href="index.source.html" class="el_package">linalg.complex_number</a> &gt; <span class="el_source">CNumber.java</span></div><h1>CNumber.java</h1><pre class="source lang-java linenums">package linalg.complex_number;

import linalg.util.Parser;

import java.math.BigDecimal;
import java.math.RoundingMode;


/**
 * This class allows for the creation of complex and real numbers and provides
 * methods for computation with those numbers.
 * 
 * @author Jacob Watters
 */
// TODO: Refactor so that binary operations are not static and preformed like A.add(B) rather then CNumber.add(A, B)
public class CNumber {
	private final static java.util.Random random = new java.util.Random();
<span class="fc" id="L18">	</span>
	/**
	 * re is real portion of complex number. im is imaginary portion of complex number.
	 */
	public double re, im;

	/**
	 * The number 1.
	 */
	public final static CNumber ONE = new CNumber(1);
<span class="fc" id="L28">	</span>
	/**
	 * The number -1.
	 */
	public final static CNumber NEGATIVE_ONE = new CNumber(-1);
<span class="fc" id="L33">	</span>
	/**
	 * The number 0.
	 */
	public final static CNumber ZERO = new CNumber(0); // the additive identity
<span class="fc" id="L38">	</span>
	/**
	 * The imaginary unit Defined as i^2=-1 =&gt; i=(-1)^(1/2).
	 */
	public final static CNumber IMAGINARY_UNIT = new CNumber(&quot;i&quot;);
<span class="fc" id="L43">	</span>
	/**
	 * The double value closer than any other to the mathmatical constant pi = 3.14159...
	 */
	public final static CNumber PI = new CNumber(Math.PI);
<span class="fc" id="L48">	</span>
	/**
	 * The double value closer than any other to Euler's Constant e = 2.71828...
	 */
	public final static CNumber E = new CNumber(Math.exp(1));
<span class="fc" id="L53">	</span>
	/**
	 * A real number holding the largest positive finite value of type double, (2-2^(-52))^21023
	 */
	public final static CNumber MAX_VALUE = new CNumber(Double.MAX_VALUE);
<span class="fc" id="L58">	</span>
	/**
	 * A real number holding the smallest possible double value,  2^(-1074)
	 */
	public final static CNumber MIN_VALUE = new CNumber(Double.MIN_VALUE);
<span class="fc" id="L63">	</span>
	// TODO: Do Javadoc for constructors
	
	public CNumber() {
<span class="nc" id="L67">		re = im = 0;</span>
<span class="nc" id="L68">	}</span>
<span class="nc" id="L69"></span>
	
	public CNumber(double real) {
<span class="fc" id="L72">		this.re = real;</span>
<span class="fc" id="L73">		im = 0;</span>
<span class="fc" id="L74">	}</span>
<span class="fc" id="L75"></span>
	
	public CNumber(double real, double imaginary) {
<span class="nc" id="L78">		this.re = real;</span>
<span class="nc" id="L79">		this.im = imaginary;</span>
<span class="nc" id="L80">	}</span>
<span class="nc" id="L81"></span>
	
	public CNumber(String num) {
<span class="fc" id="L84">		double[] content = Parser.parseNumber(num);</span>
<span class="fc" id="L85"></span>
		re = content[0];
<span class="fc" id="L87">		im = content[1];</span>
<span class="fc" id="L88">	}</span>
<span class="fc" id="L89"></span>
	
	public CNumber(CNumber n) {
<span class="fc" id="L92">		this.re = n.re;</span>
<span class="fc" id="L93">		this.im = n.im;</span>
<span class="fc" id="L94">	}</span>
<span class="fc" id="L95"></span>

	/**
	 * Generates a random real or complex number a, or a+bi where a and b are
	 * normaly distributed psedorandom numbers with a mean of zero and standard deviation of one.
	 * 
	 * @param complex - selects if a real or complex number should be selected..
	 * @return If &lt;code&gt;complex&lt;/code&gt; false, a random real number is returned. If &lt;code&gt;complex&lt;/code&gt; true, a random real and imaginary component are chosen
	 * and a complex number is returned.
	 */
	public static CNumber randn(boolean complex) {
		double real = random.nextGaussian();
<span class="nc" id="L107">		double imaginary;</span>
		
		if(complex) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">			imaginary = random.nextGaussian();</span>
<span class="nc" id="L111">			return new CNumber(real, imaginary);</span>
<span class="nc" id="L112">		} else {</span>
			return new CNumber(real);
<span class="nc" id="L114">		}</span>
	}
	
	
	/**
	 * Generates a random real a where a is a
	 * normaly distributed psedorandom number with a mean of zero and standard deviation of one.
	 * 
	 * @return A random real number from a standard normal distribution.
	 */
	public static CNumber randn() {
		return randn(false);
<span class="nc" id="L126">	}</span>

	/**
	 * Generates a random real number.
	 * 
	 * @return random real number
	 */
	public static CNumber random() {
		return new CNumber(Math.random());
<span class="nc" id="L135">	}</span>

	
	/**
	 * Generates a random complex number with given magnitude.
	 * Note: the magnitude must be a non-negative real number.
	 * 
	 * @param mag - magnitude
	 * @return random complex number with specified magnitude.
	 */
	public static CNumber random(double mag) {
		
		if(mag &lt; 0) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Magnitude must be non-negative.&quot;);</span>
<span class="nc" id="L149">		}</span>
		
		// By Pythagorean theorem, this will result in a complex number with specified magnitude 
		double real = Math.random() * (mag);
<span class="nc" id="L153">		double imaginary = Math.sqrt(Math.pow(mag, 2) - Math.pow(real, 2));</span>
<span class="nc" id="L154"></span>
		CNumber[] result_list = {new CNumber(real, imaginary),  // 1st quadrent result
<span class="nc" id="L156">								new CNumber(-real, imaginary),  // 2nd quadrent result</span>
								new CNumber(-real, -imaginary),  // 3rd quadrent result
								new CNumber(real, -imaginary)}; // 4th quadrent result
		
		return result_list[random.nextInt(4)]; // Choose random 
<span class="nc" id="L161">	}</span>

	
	/**
	 * Generates a random number between min and max. 
	 * 
	 * If magnitude_flag is passed a true, then a random complex number with magnitude
	 * between min and max (where min and max are non-negative values) is generated.
	 * 
	 * If magnitude_flag is passed a false, then a random real value between min and max is 
	 * generated. 
	 * 
	 * If no magnitude_flag is passed, then it is treated as false. 
	 * 
	 * @param min - minimum value for random number
	 * @param max - maximum value for random number
	 * @param magnitude_flag - optional flag to indicate if the Number should be real or complex.
	 * @return random real or complex number between min and max. 
	 */
	public static CNumber random(double min, double max, boolean... magnitude_flag) {
		if(magnitude_flag.length &gt; 1) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Can have at most one optional flag but got &quot; + magnitude_flag.length);</span>
<span class="nc" id="L183">		}</span>
		
		if(min &gt; max) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;min must be less than or equal to max but recieved &quot;</span>
<span class="nc" id="L187">					+ &quot;min: &quot; + min + &quot; and max: &quot; + max);</span>
		}
		
		if (magnitude_flag.length &gt; 0 &amp;&amp; magnitude_flag[0] == true) {
<span class="nc bnc" id="L191" title="All 4 branches missed.">			if(min &lt; 0 || max &lt; 0) {</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">				throw new IllegalArgumentException(&quot;For complex numbers, min and max must be non-negative values but recieved &quot;</span>
<span class="nc" id="L193">						+ &quot;min: &quot; + min + &quot; and max: &quot; + max);</span>
			}
			
			double mag = Math.random() * (max - min) + min;
<span class="nc" id="L197">			return random(mag);</span>
<span class="nc" id="L198">		} else {</span>
			return new CNumber(Math.random() * (max - min) + min);
<span class="nc" id="L200">		}</span>
	}

	
	/**
	 * Computes and returns complex conjugate of a complex number. For example the
	 * complex conjugate of &lt;code&gt;a+bi&lt;/code&gt; is &lt;code&gt;a-bi&lt;/code&gt;.
	 * 
	 * @param a - complex number
	 * @return complex conjugate of &lt;code&gt;a&lt;/code&gt;
	 */
	public static CNumber conjugate(CNumber a) {
		return new CNumber(a.re, -a.im);
<span class="nc" id="L213">	}</span>

	
	/**
	 * Performs complex addition of two numbers.
	 * 
	 * @param a - complex number
	 * @param b - complex number
	 * @return sum of a and b. e.g. a+b
	 */
	public static CNumber add(CNumber a, CNumber b) {
		return new CNumber(a.re + b.re, a.im + b.im);
<span class="nc" id="L225">	}</span>

	
	/**
	 * Performs complex addition of two or more numbers.
	 * 
	 * @param a - complex number
	 * @param b - complex number
	 * @param values - Optional list of additional values to sum
	 * @return Sum of complex numbers. 
	 */
	public static CNumber add(CNumber a, CNumber b, CNumber... values) {
		
		double realSum = a.re + b.re;
<span class="nc" id="L239">		double imaginarySum = a.im + b.im;</span>
<span class="nc" id="L240">		</span>
		for(int i=0; i &lt; values.length; i++) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">			realSum += values[i].re;</span>
<span class="nc" id="L243">			imaginarySum += values[i].im;</span>
<span class="nc" id="L244">		}</span>
		
		return new CNumber(realSum, imaginarySum);
<span class="nc" id="L247">	}</span>
	
	
	/**
	 * Performs complex subtraction of two numbers.
	 * 
	 * @param a - complex number
	 * @param b - complex number
	 * @return difference of a and b. e.g. a-b
	 */
	public static CNumber subtract(CNumber a, CNumber b) {
		return new CNumber(a.re - b.re, a.im - b.im);
<span class="nc" id="L259">	}</span>

	
	/**
	 * Performs complex multiplication of two numbers.
	 * 
	 * @param a - complex number
	 * @param b - complex number
	 * @return product of a and b. e.g. a*b
	 */
	public static CNumber multiply(CNumber a, CNumber b) {
		return new CNumber(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
<span class="nc" id="L271">	}</span>

	
	/**
	 * Performs complex division of two numbers.
	 * 
	 * @param a - complex number
	 * @param b - complex number
	 * @return Quotient of a and b. e.g. a/b
	 */
	public static CNumber divide(CNumber a, CNumber b) {
		CNumber quotent = null;
<span class="nc" id="L283"></span>
		if (a.equals(ZERO) &amp;&amp; !b.equals(ZERO)) {
<span class="nc bnc" id="L285" title="All 4 branches missed.">			quotent = ZERO;</span>
<span class="nc" id="L286">		} else if (b.equals(ZERO)) { // Can not divide by zero</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Can not divide by zero&quot;);</span>
<span class="nc" id="L288">		} else {</span>
			quotent = new CNumber(
<span class="nc" id="L290">					(a.re * b.re + a.im * b.im) / (b.re * b.re + b.im * b.im),</span>

					(a.im * b.re - a.re * b.im) / (b.re * b.re + b.im * b.im));
		}

		return quotent;
<span class="nc" id="L296">	}</span>

	
	/**
	 * Computes absolute value of a number. Note: this will
	 * Always result in a non-negative real number. 
	 * &lt;br&gt;
	 * This method is the same as {@link #mag() mag()}
	 * 
	 * @param value - value to take absolute value of.
	 * @return The absolute value of the number.
	 */
	public static CNumber abs(CNumber value) {
		return new CNumber(value.mag());
<span class="nc" id="L310">	}</span>
	
	
	/**
	 * Computes the multiplicative inverse of a Number. For example, given a number n, the inverse
	 * is 1/n. 
	 * 
	 * This is equivalent to &lt;code&gt; Number.divide(Number.ONE, value); &lt;/code&gt;
	 * 
	 * @param value - Number to take inverse of
	 * @return - Inverse of value
	 */
	public static CNumber inv(CNumber value) {
		return CNumber.divide(ONE, value);
<span class="nc" id="L324">	}</span>
	
	
	/**
	 * Computes the additive inverse of a Number. For example, given a number n, the inverse
	 * is -n. 
	 * 
	 * This is equivalent to &lt;code&gt; Number.subtract(Number.ZERO, value); &lt;/code&gt;
	 * 
	 * @param value - Number to take inverse of
	 * @return - Inverse of value
	 */
	public static CNumber addInv(CNumber value) {
		return CNumber.subtract(ZERO, value);
<span class="nc" id="L338">	}</span>
	
	
	/**
	 * Performs complex exponentiation of two numbers. Note: &lt;code&gt;base&lt;/code&gt; can
	 * be any complex number.
	 * 
	 * TODO: Extend this using to complex numbers using Talyor series expansion of e^x. (May need a new method exponenent()) 
	 * 
	 * @param base - base of exponential expression
	 * @param exponenent - exponent of exponential expression
	 * @return Result of the exponential expression &lt;code&gt;base^exponenent&lt;/code&gt;
	 */
	public static CNumber pow(CNumber base, int exponenent) {

		CNumber result;

		if (exponenent == 0) { // Exponent is zero
<span class="nc bnc" id="L356" title="All 2 branches missed.">			result = CNumber.ONE;</span>
<span class="nc" id="L357">		} else if (exponenent &gt; 0) { // Exponent is positive</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">			result = base;</span>
<span class="nc" id="L359"></span>
			for (int i = 1; i &lt; exponenent; i++) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">				result = CNumber.multiply(result, base);</span>
<span class="nc" id="L362">			}</span>
		} else { // Exponent is negative
			result = base;
<span class="nc" id="L365"></span>
			for (int i = -1; i &gt; exponenent; i--) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">				result = CNumber.multiply(result, base);</span>
<span class="nc" id="L368">			}</span>

			result = CNumber.divide(CNumber.ONE, result);
<span class="nc" id="L371">		}</span>

		return result;
<span class="nc" id="L374">	}</span>

	
	/**
	 * Performs complex exponentiation of two numbers. Note: The exponent, must be a real integer.
	 * 
	 * TODO: Extend this using to complex numbers using Talyor series expansion of e^x. (May need a new method exp()) 
	 * 
	 * @param base - base of exponential expression
	 * @param exponent - exponent of exponential expression
	 * @return Result of the exponential expression &lt;code&gt;base^exp&lt;/code&gt;
	 */
	public static CNumber pow(CNumber base, CNumber exponent) {
		CNumber result = null;
<span class="nc" id="L388"></span>
		if (exponent.isComplex()) { // Then we dont have a real number
<span class="nc bnc" id="L390" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Exponent must be an real number but got &quot; + exponent);</span>
<span class="nc" id="L391">		} else if (exponent.isInt()) { // Then we dont have an integer</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Exponent must be an integer but got &quot; + exponent);</span>
<span class="nc" id="L393">		} else {</span>
			result = pow(base, Integer.parseInt(exponent.toString()));
<span class="nc" id="L395">		}</span>

		return result;
<span class="nc" id="L398">	}</span>

	
	/**
	 * 
	 * @param x - exponent
	 * @return e^x
	 */
	public static CNumber exp(double x) {
		// TODO: implementation using min max
		return null;
<span class="nc" id="L409">	}</span>
	
	
	/**
	 * 
	 * @param x - exponent
	 * @return e^x
	 */
	public static CNumber exp(CNumber x) {
		// TODO: implementation using min max
		return null;
<span class="nc" id="L420">	}</span>
	
	
	/**
	 * Computes the square root of a number.&lt;br&gt;&lt;br&gt;
	 * Note: This method only returns the principle square root 
	 * (the positive square root or square root with positive real part).
	 * &lt;br&gt;If you wish to see all square roots, see {@link #allSqrt(CNumber) allSqrt(CNumber value)}
	 * 
	 * @param value - value to take square root of.
	 * @return Returns the square root of value.
	 */
	public static CNumber sqrt(CNumber value) {
		CNumber result;
		
		if(value.isReal()) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">			if(value.compareToReal(CNumber.ZERO) &gt;= 0) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">				result = new CNumber(Math.sqrt(value.re));</span>
<span class="nc" id="L438">			} else { // Then the number is negative</span>
				result = new CNumber(0, Math.sqrt(-1*value.re));
<span class="nc" id="L440">			}</span>
		} else { // Then the number is complex.
			CNumber r = new CNumber(value.mag());
<span class="nc" id="L443">			</span>
			result = CNumber.multiply(
<span class="nc" id="L445">						sqrt(r), </span>
<span class="nc" id="L446">						CNumber.divide(</span>
<span class="nc" id="L447">							CNumber.add(value, r),</span>
<span class="nc" id="L448">							new CNumber(CNumber.add(value, r).mag())</span>
<span class="nc" id="L449">						)</span>
					);
			if(result.isReal() &amp;&amp; result.compareToReal(CNumber.ZERO) &lt; 0) {
<span class="nc bnc" id="L452" title="All 4 branches missed.">				throw new ArithmeticException(&quot;No principle root exists for the complex number &quot; + value);</span>
<span class="nc" id="L453">			}</span>
		}
		
		return result;
<span class="nc" id="L457">	}</span>

	
	/**
	 * Computes all possible square roots of a number.
	 * If you would only like the principle square root then see {@link #sqrt(CNumber) sqrt(CNumber value)} 
	 * 
	 * @param value - value to take square root of.
	 * @return Returns all square roots of value (both positive and negative) in an array.
	 */
	public static CNumber[] allSqrt(CNumber value) {
		CNumber[] result = new CNumber[2];
<span class="nc" id="L469">		result[0] = CNumber.sqrt(value);</span>
<span class="nc" id="L470">		result[1] = CNumber.multiply(CNumber.NEGATIVE_ONE, result[0]);</span>
<span class="nc" id="L471">		return result;</span>
<span class="nc" id="L472">	}</span>
	
	
	/**
	 * The complex signum function. 
	 * 
	 * @param value Value to evaluate the signum function at.
	 * @return If the number is zero then this function returns One. Otherwise, returns the number divided by its magnitude.
	 */
	public static CNumber sign(CNumber value) {
		if(value.equals(CNumber.ZERO)) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">			return CNumber.ONE;</span>
<span class="nc" id="L484">		}</span>

		return CNumber.divide(value, new CNumber(value.mag()));
<span class="nc" id="L487">	}</span>
	
	
	/**
	 * Checks for equivalence between two complex numbers
	 * 
	 * @param b - Number to check equivalence to
	 * @return True if the two numbers are equivalent. Otherwise, returns false.
	 */
	public boolean equals(Object b) { // TODO: Change to equals(Object)
		boolean result = false;
<span class="fc" id="L498"></span>
		if(b instanceof CNumber) {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">			CNumber c = (CNumber) b;</span>
<span class="fc" id="L501"></span>
			if (this.re == c.re &amp;&amp; this.im == c.im) { // Then the two numbers are equal
<span class="pc bpc" id="L503" title="2 of 4 branches missed.">				result = true;</span>
<span class="fc" id="L504">			}</span>
		}

		return result;
<span class="fc" id="L508">	}</span>
	
	
	/**
	 * Checks for equivalence between two complex numbers
	 * &lt;br&gt;&lt;br&gt;
	 * Also see {@link #equals(Object)}
	 * 
	 * @param b - Number to check equivalence to
	 * @return True if the two numbers are equivalent. Otherwise, returns false.
	 */
	public boolean equals(double b) {
		boolean result = false;
<span class="nc" id="L521"></span>
		if (this.re==b &amp;&amp; this.im==0) { // Then the two numbers are equal
<span class="nc bnc" id="L523" title="All 4 branches missed.">			result = true;</span>
<span class="nc" id="L524">		}</span>

		return result;
<span class="nc" id="L527">	}</span>
	
	
	/**
	 * Rounds number to specified number of decimal places. If the number is complex,
	 * both the real and imaginary parts will be rounded.
	 * 
	 * @param n - Number to round.
	 * @param decimals - Number of decimals to round to.
	 * @return The number &lt;code&gt;n&lt;/code&gt; rounded to the specified
	 * 		number of decimals.
	 */
	public static CNumber round(CNumber n, int decimals) {
		
		if (decimals &lt; 0) {
<span class="nc bnc" id="L542" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Number of decimals must be non-negative but got &quot; +</span>
<span class="nc" id="L543">					decimals);</span>
		}
		
	    double real = BigDecimal.valueOf(n.re).setScale(decimals, RoundingMode.HALF_UP).doubleValue();
<span class="nc" id="L547">	    double imaginary = BigDecimal.valueOf(n.im).setScale(decimals, RoundingMode.HALF_UP).doubleValue();</span>
<span class="nc" id="L548">	    </span>
	    return new CNumber(real, imaginary);
<span class="nc" id="L550">	}</span>
	
	
	/**
	 * Checks if a number is near zero.
	 * 
	 * @param tol - tolerance of how close to zero is
	 * 		considered &quot;near&quot;.
	 * @return Returns true if magnitude of number is less than or equal to 
	 * 		&lt;code&gt;tol&lt;/code&gt; of zero. Otherwise, returns false.
	 * 
	 */
	public boolean nearZero(double tol) {
		return this.mag() &lt;= tol;
<span class="nc bnc" id="L564" title="All 2 branches missed.">	}</span>
	
	
	/**
	 * Compares the size of two complex numbers (magnitudes). 
	 * 
	 * @param b - Number to compare
	 * @return
	 * - If the magnitude of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
	 * - If the magnitude of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
	 * - If the magnitude of this number is greater than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
	 */
	public int compareTo(CNumber b) {
		if(this.mag() == b.mag()) {return 0;}
<span class="nc bnc" id="L578" title="All 2 branches missed.">		else if(this.mag() &lt; b.mag()) {return -1;}</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">		else {return 1;}</span>
<span class="nc" id="L580">	}</span>
	
	
	/**
	 * Compares the real value of two numbers. 
	 * 
	 * @param b - Number to compare
	 * @return
	 * - If the real value of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
	 * - If the real value of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
	 * - If the real value of this number is greator than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
	 */
	public int compareToReal(CNumber b) {
		if(this.re == b.re) {return 0;}
<span class="nc bnc" id="L594" title="All 2 branches missed.">		else if(this.re &lt; b.re) {return -1;}</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">		else {return 1;}</span>
<span class="nc" id="L596">	}</span>
	
	
	/**
	 * Compares the real value of two numbers. 
	 * 
	 * @param b - Number to compare
	 * @return
	 * - If the real value of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
	 * - If the real value of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
	 * - If the real value of this number is greater than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
	 */
	public int compareToReal(double b) {
		return this.compareToReal(new CNumber(b));
<span class="nc" id="L610">	}</span>

	
	/**
	 * Computes the magnitude of a complex number (The numbers distance from the
	 * origin in the complex plane). &lt;br&gt;
	 * This method is the same as {@link #abs(CNumber)}
	 * 
	 * @return magnitude of complex number
	 */
	// TODO: refactor so that the return type is CNumber to make arithmetic with magnitudes easier. Also, add magAsDouble()
	public double mag() {
		return Math.sqrt(this.re * this.re + this.im * this.im);
<span class="nc" id="L623">	}</span>

	
	/**
	 * Computes value with greatest magnitude amongst all passed values. 
	 * 
	 * @param values - a set of values of which to compute the maximum. Each item may be passed as its own variable or as an array.
	 * 	For example, given the CNumbers a, b, c and an array of CNumbers vals, this method may be called in either of the following ways.&lt;br&gt;
	 * 	- &lt;code&gt;CNumber.max(a, b, c)&lt;/code&gt;&lt;br&gt;
	 *  - &lt;code&gt;CNumber.max(vals)&lt;/code&gt;
	 *   
	 * @return Returns value with maximum magnitude amongst values. If two values tie for largest, the first encountered will be returned.
	 */
	public static CNumber max(CNumber... values) {
		CNumber currMax = CNumber.MIN_VALUE;
<span class="nc" id="L638">		</span>
		for(CNumber val : values) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">			if(val.mag() &gt; currMax.mag()) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">				currMax = val;</span>
<span class="nc" id="L642">			}</span>
		}
		
		return currMax;
<span class="nc" id="L646">	}</span>
	
	
	/**
	 * Computes value with smallest magnitude amongst all passed values.
	 * 
	 * @param values - a set of values of which to compute the minimum. Each item may be passed as its own variable or as an array.
	 * 	For example, given the CNumbers a, b, c and an array of CNumbers vals, this method may be called in either of the following ways.&lt;br&gt;
	 * 	- &lt;code&gt;CNumber.max(a, b, c)&lt;/code&gt;&lt;br&gt;
	 *  - &lt;code&gt;CNumber.max(vals)&lt;/code&gt;
	 * 
	 * @return Returns value with minimum magnitude amounts values. If two values tie for smallest, the first encountered will be returned.
	 */
	public static CNumber min(CNumber... values) {
		CNumber currMin = CNumber.MAX_VALUE;
<span class="nc" id="L661">		</span>
		for(CNumber val : values) {
<span class="nc bnc" id="L663" title="All 2 branches missed.">			if(val.mag() &lt; currMin.mag()) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">				currMin = val;</span>
<span class="nc" id="L665">			}</span>
		}
		
		return currMin;
<span class="nc" id="L669">	}</span>
	
	
	/**
	 * @return Real part of number
	 */
	public double getReal() {
		return re;
<span class="nc" id="L677">	}</span>

	
	/**
	 * @return Complex part of number
	 */
	public double getImaginary() {
		return im;
<span class="nc" id="L685">	}</span>

	
	/**
	 * Checks if given number has no imaginary part.
	 * 
	 * @return true if given Number has no imaginary part. Otherwise, returns false.
	 */
	public boolean isReal() {
		return im == 0;
<span class="nc bnc" id="L695" title="All 2 branches missed.">	}</span>
	
	
	/**
	 * Checks if given number has non-zero imaginary part.
	 * 
	 * @return true if given Number has non-zero imaginary part. Otherwise, returns false.
	 */
	public boolean isComplex() {
		return im != 0;
<span class="nc bnc" id="L705" title="All 2 branches missed.">	}</span>
	
	
	/**
	 * Checks if given number has no real part.
	 * 
	 * @return true if given Number has no real part and non-zero imaginary part. Otherwise, returns false.
	 */
	public boolean isImaginary() {
		return re==0 &amp;&amp; im != 0;
<span class="nc bnc" id="L715" title="All 4 branches missed.">	}</span>
	
	
	/**
	 * Checks if a give number is a real integer.
	 * 
	 * @return true if number is a real integer. Otherwise, returns false.
	 */
	public boolean isInt() {
		boolean result = true;
<span class="nc" id="L725"></span>
		if (this.isComplex()) { // Then we have a complex number.
<span class="nc bnc" id="L727" title="All 2 branches missed.">			result = false;</span>
<span class="nc" id="L728">		} else if (Double.parseDouble(this.toString()) == Math.floor(Double.parseDouble(this.toString()))) { </span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">			// Then we have a real non-integer.</span>
			result = false;
<span class="nc" id="L731">		}</span>

		return result;
<span class="nc" id="L734">	}</span>

	
	/**
	 * @return real part of given Number as double
	 */
	public double doubleValue() {
		return re;
<span class="nc" id="L742">	}</span>
	

	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return real part of given Number as float
	 */
	public float floatValue() {
		return (float) re;
<span class="nc" id="L752">	}</span>
	

	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return real part of given Number as int
	 */
	public int intValue() {
		return (int) re;
<span class="nc" id="L762">	}</span>

	
	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return real part of given Number as double
	 */
	public long longValue() {
		return (long) re;
<span class="nc" id="L772">	}</span>

	
	/**
	 * @return imaginary part of given Number as double
	 */
	public double doubleImaginaryValue() {
		return im;
<span class="nc" id="L780">	}</span>

	
	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return imaginary part of given Number as float
	 */
	public float floatImaginaryValue() {
		return (float) im;
<span class="nc" id="L790">	}</span>

	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return imaginary part of given Number as int
	 */
	public int intImaginaryValue() {
		return (int) im;
<span class="nc" id="L799">	}</span>

	
	/**
	 * Note: This method may result in loss of accuracy
	 * 
	 * @return imaginary part of given Number as long
	 */
	public long longImaginaryValue() {
		return (long) im;
<span class="nc" id="L809">	}</span>

	
	/**
	 * @param a - a number
	 * @return The length of the string representation of the number
	 */
	public static int length(CNumber a) {
		return a.toString().length();
<span class="nc" id="L818">	}</span>
	
	
	public String toString() {
		String result = &quot;&quot;;
<span class="nc" id="L823"></span>
		double real = this.re, imaginary = this.im;
<span class="nc" id="L825"></span>
		if (real != 0) {
<span class="nc bnc" id="L827" title="All 2 branches missed.">			if (real % 1 == 0) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">				result += (int) real;</span>
<span class="nc" id="L829">			} else {</span>
				result += real;
<span class="nc" id="L831">			}</span>
		}

		if (imaginary != 0) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">			if (imaginary &lt; 0 &amp;&amp; real != 0) {</span>
<span class="nc bnc" id="L836" title="All 4 branches missed.">				result += &quot; - &quot;;</span>
<span class="nc" id="L837">				imaginary = -imaginary;</span>
<span class="nc" id="L838">			} else if (real != 0) {</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">				result += &quot; + &quot;;</span>
<span class="nc" id="L840">			}</span>

			if (imaginary % 1 == 0) {
<span class="nc bnc" id="L843" title="All 2 branches missed.">				if(imaginary != 1) {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">					if(imaginary == -1) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">						result += '-';</span>
<span class="nc" id="L846">					} else {</span>
						result += (int) imaginary;
<span class="nc" id="L848">					}</span>
				}			
			} else {
				result += imaginary;
<span class="nc" id="L852">			}</span>

			result += &quot;i&quot;;
<span class="nc" id="L855">		}</span>

		if (real == 0 &amp;&amp; imaginary == 0) {
<span class="nc bnc" id="L858" title="All 4 branches missed.">			result = &quot;0&quot;;</span>
<span class="nc" id="L859">		}</span>

		return result;
<span class="nc" id="L862">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>