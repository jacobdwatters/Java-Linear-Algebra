<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatrixOperations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java-Linear-Algebra</a> &gt; <a href="index.source.html" class="el_package">linalg</a> &gt; <span class="el_source">MatrixOperations.java</span></div><h1>MatrixOperations.java</h1><pre class="source lang-java linenums">package linalg;

import linalg.complex_number.CNumber;
import linalg.concurrent.ConcurrentMatrixAddition;

/**
 * This interface provides several methods useful for matrix operations.
 *
 * @author Jacob Watters
 */
interface MatrixOperations {


	/**
	 * Performs matrix addition on two matrices of the same dimensions.
	 *
	 * @param B - matrix to add to the instance matrix
	 * @return result of matrix addition
	 */
	default Matrix add(Matrix B) {
<span class="nc" id="L21">		Matrix A = (Matrix) this;</span>
		Matrix sum;

<span class="nc" id="L24">		CNumber[][] C = new CNumber[A.m][A.n];</span>
<span class="nc" id="L25">		MatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);</span>

		// TODO: Is this really the best way to determine if the concurrent algorithm should be used.
<span class="nc bnc" id="L28" title="All 8 branches missed.">		if((A.m &gt; 1200 &amp;&amp; A.n &gt; 1200) || A.m &gt; 80000 || A.n &gt; 80000) {</span>
			// Use concurrent algorithm.
<span class="nc" id="L30">			ConcurrentMatrixAddition adder = new ConcurrentMatrixAddition(A, B);</span>
<span class="nc" id="L31">			sum = adder.add();</span>

<span class="nc" id="L33">		} else {</span>

			// Use standard algorithm
<span class="nc bnc" id="L36" title="All 2 branches missed.">			for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">				for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc bnc" id="L38" title="All 4 branches missed.">					if(A.entries[i][j].isReal() &amp;&amp; B.entries[i][j].isReal()) {</span>
<span class="nc" id="L39">						C[i][j] = new CNumber(A.entries[i][j].re + B.entries[i][j].re,</span>
								0);
					} else {
<span class="nc" id="L42">						C[i][j] = new CNumber(A.entries[i][j].re + B.entries[i][j].re,</span>
								A.entries[i][j].im + B.entries[i][j].im);
					}
				}
			}

<span class="nc" id="L48">			sum = new Matrix(C);</span>
		}

<span class="nc" id="L51">		return sum;</span>
	}


	/**
	 * Adds the value of a to all entries of matrix.
	 * @param a Value to add to matrix.
	 * @return A new matrix with the value of a added to this matrix.
	 */
	default Matrix add(double a) {
<span class="nc" id="L61">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L62">		CNumber[][] C = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L64" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L66">				C[i][j] = new CNumber(A.entries[i][j].re + a, A.entries[i][j].im);</span>
			}
		}

<span class="nc" id="L70">		return new Matrix(C);</span>
	}


	/**
	 * Performs matrix subtraction on two matrices of the same dimensions.
	 *
	 * @param B - matrix to subtract to the instance matrix
	 * @return result of matrix subtraction
	 */
	default Matrix sub(Matrix B) {
<span class="nc" id="L81">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L82">		CNumber[][] C = new CNumber[A.m][A.n];</span>
<span class="nc" id="L83">		MatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L87">				C[i][j] = new CNumber(A.entries[i][j].re - B.entries[i][j].re,</span>
						A.entries[i][j].im - B.entries[i][j].im);
			}
		}

<span class="nc" id="L92">		return new Matrix(C);</span>
	}


	/**
	 * Subtracts the value of a from all entries of matrix.
	 * @param a Value to subtract from matrix.
	 * @return A new matrix with the value of a added to this matrix.
	 */
	default Matrix sub(double a) {
<span class="nc" id="L102">		return this.add(-a);</span>
	}


	/**
	 * Subtracts the value of a from all entries of matrix.
	 * @param a Value to subtract from matrix.
	 * @return A new matrix with the value of a added to this matrix.
	 */
	default Matrix sub(CNumber a) {
<span class="nc" id="L112">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L113">		CNumber[][] difference = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L117">				difference[i][j] = CNumber.subtract(A.entries[i][j], a);</span>
			}
		}

<span class="nc" id="L121">		return new Matrix(difference);</span>
	}


	/**
	 * Performs matrix multiplication on two matrices. The instance matrix
	 * must have the same number of columns as the rows of B.
	 *
	 * If the instance matrix is a kxm matrix and B is a
	 * m x n matrix then the result will be a k x n matrix.
	 *
	 * @param B - matrix to multiply to the instance matrix
	 * @return result of matrix multiplication
	 */
	default Matrix mult(Matrix B) {
<span class="nc" id="L136">		Matrix A = (Matrix) this;</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">		if(!MatrixComparisons.matMultCheck(A, B)) {</span>
<span class="nc" id="L139">			throw new IllegalArgumentException(&quot;Number of columns in first matrix must match \n&quot;</span>
<span class="nc" id="L140">					+ &quot;number of rows in second matrix but got &quot; + A.shape() + &quot; and &quot; + B.shape() + &quot;.&quot;);</span>
		}

		Matrix product;

<span class="nc bnc" id="L145" title="All 2 branches missed.">		if(B.n==1) { // Then we have a column vector.</span>
<span class="nc" id="L146">			product = MatrixMultiplicationAlgorithms.matrixVector(A, B);</span>
<span class="nc bnc" id="L147" title="All 6 branches missed.">		} else if(A.n+A.m &gt;= 500 || A.m &gt;= 1000 || A.n &gt;= 1000) {</span>
			// TODO: use concurrent
<span class="nc" id="L149">			product = MatrixMultiplicationAlgorithms.concurrent(A, B);</span>
		} else {
<span class="nc" id="L151">			product = MatrixMultiplicationAlgorithms.standard(A, B);</span>
		}

<span class="nc" id="L154">		return product;</span>
	}


	/**
	 * Performs matrix-vector multiplication with a column matrix. The vector MUST be a column vector.
	 *
	 * @param B - Column vector to multiply to the instance matrix.
	 * @return result of matrix-vector multiplication.
	 */
	default Vector mult(Vector B) {
<span class="nc" id="L165">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L166">		Vector product = new Vector(A.m);</span>
		Vector b;

<span class="nc bnc" id="L169" title="All 2 branches missed.">		if(B.type==0) { // Then transpose</span>
<span class="nc" id="L170">			b = B.T();</span>
		} else {
<span class="nc" id="L172">			throw new IllegalArgumentException(&quot;Expecting column vector but got a row vector.&quot;);</span>
		}

<span class="nc bnc" id="L175" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L177">				product.entries[i][0].re += (A.entries[i][j].re*b.entries[0][j].re - A.entries[i][j].im*b.entries[0][j].im);</span>
<span class="nc" id="L178">				product.entries[i][0].im += (A.entries[i][j].re*b.entries[0][j].im + A.entries[i][j].im*b.entries[0][j].re);</span>
			}
		}

<span class="nc" id="L182">		return product;</span>
	}



	/**
	 * Performs element-wise multiplication of two matrices.
	 *
	 * @throws IllegalArgumentException If matrices do not have the same dimension.
	 * @param B - matrix to multiply element-wise to this matrix.
	 * @return result of element-wise matrix multiplication.
	 */
	default Matrix elemMult(Matrix B) {
<span class="nc" id="L195">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L196">		CNumber[][] C = new CNumber[A.m][A.n];</span>
<span class="nc" id="L197">		MatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);</span>

<span class="nc bnc" id="L199" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>

<span class="nc" id="L202">				C[i][j] = new CNumber(A.entries[i][j].re*B.entries[i][j].re - A.entries[i][j].im*B.entries[i][j].im,</span>
						A.entries[i][j].re*B.entries[i][j].im + A.entries[i][j].im*B.entries[i][j].re);
			}
		}

<span class="nc" id="L207">		return new Matrix(C);</span>
	}



	/**
	 * Performs scalar multiplication of a matrix.
	 *
	 * @param factor - value to multiply this matrix by.
	 * @return The scalar multiplication of the matrix and the factor.
	 */
	default Matrix scalMult(double factor) {
<span class="nc" id="L219">		return this.scalMult(new CNumber(factor));</span>
	}


	/**
	 * Performs scalar multiplication of a matrix.
	 *
	 * @param factor - value to multiply matrix by.
	 * @return The scalar multiplication of the matrix and the factor.
	 */
	default Matrix scalMult(CNumber factor) {
<span class="nc" id="L230">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L231">		CNumber[][] result = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			for(int j = 0; j &lt;  A.n; j++) {</span>
<span class="nc" id="L235">				result[i][j] = new CNumber(A.entries[i][j].re*factor.re - A.entries[i][j].im*factor.im,</span>
						A.entries[i][j].re*factor.im + A.entries[i][j].im*factor.re);
			}
		}

<span class="nc" id="L240">		return new Matrix(result);</span>
	}


	/**
	 * Performs element-wise division on two matrices of the same dimensions.
	 *
	 * @param B - matrix to divide element-wise the instance matrix with.
	 * @return result of element-wise matrix multiplication.
	 */
	default Matrix elemDiv(Matrix B) {
<span class="nc" id="L251">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L252">		CNumber[][] C = new CNumber[A.m][A.n];</span>
<span class="nc" id="L253">		MatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L257">				C[i][j] = new CNumber((A.entries[i][j].re*B.entries[i][j].re + A.entries[i][j].im*B.entries[i][j].im) /</span>
						(B.entries[i][j].re*B.entries[i][j].re + B.entries[i][j].im*B.entries[i][j].im),

						(A.entries[i][j].im*B.entries[i][j].re - A.entries[i][j].re*B.entries[i][j].im) /
								(B.entries[i][j].re*B.entries[i][j].re + B.entries[i][j].im*B.entries[i][j].im)
				);
			}
		}

<span class="nc" id="L266">		return new Matrix(C);</span>
	}


	/**
	 * Performs scalar division of this matrix.
	 *
	 * @param divisor - value to divide matrix by.
	 * @return The scalar division of the matrix and the divisor.
	 */
	default Matrix scalDiv(double divisor) {
<span class="nc" id="L277">		double factor = 1/divisor;</span>
<span class="nc" id="L278">		return this.scalMult(new CNumber(factor));</span>
	}


	/**
	 * Performs scalar division of this matrix.
	 *
	 * @param divisor - value to divide matrix by.
	 * @return The scalar division of the matrix and the divisor.
	 */
	default Matrix scalDiv(CNumber divisor) {
<span class="nc" id="L289">		CNumber factor = CNumber.divide(CNumber.ONE, divisor);</span>
<span class="nc" id="L290">		return this.scalMult(factor);</span>
	}


	/**
	 * Computes the Frobenius inner product of two matrices A and B, {@code &lt;A, B&gt;}&lt;sub&gt;F&lt;/sub&gt;.
	 *
	 * @param B - Second matrix for the Frobenius inner product.
	 * @return the Frobenius inner product.
	 */
	default CNumber fip(Matrix B) {
<span class="nc" id="L301">		return this.mult(B).tr();</span>
	}


	/**
	 * Computes the matrix direct sum. That is, a block diagonal matrix containing all matrices from a set of matrices.
	 *
	 * @param matrixList - List of matrices from which to compute the matrix direct sum.
	 * @return The result of direct summing the matrices in matrixList to this matrix.
	 */
	default Matrix directSum(Matrix... matrixList) { // TODO: Because this is not static, include &quot;this&quot; in the direct sum.
<span class="nc" id="L312">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L313">		int new_m = A.m, new_n = A.n,</span>
<span class="nc" id="L314">				current_m = 0, current_n = 0;</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">		for(int i=0; i&lt;matrixList.length; i++) {</span>
<span class="nc" id="L317">			new_m += matrixList[i].m;</span>
<span class="nc" id="L318">			new_n += matrixList[i].n;</span>
		}


<span class="nc" id="L322">		Matrix directSum = new Matrix(new_m, new_n);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">		for(int i=-1; i&lt;matrixList.length; i++) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			if(i==-1) {</span>
<span class="nc" id="L326">				directSum.setSlice(current_m, current_n, A);</span>
<span class="nc" id="L327">				current_m += A.m;</span>
<span class="nc" id="L328">				current_n += A.n;</span>
			} else {
<span class="nc" id="L330">				directSum.setSlice(current_m, current_n, matrixList[i]);</span>
<span class="nc" id="L331">				current_m += matrixList[i].m;</span>
<span class="nc" id="L332">				current_n += matrixList[i].n;</span>
			}
		}

<span class="nc" id="L336">		return directSum;</span>
	}


	default Matrix sudoDirectSum(Matrix... matrixList) {
<span class="nc" id="L341">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L342">		int new_m = A.m, new_n = A.n,</span>
<span class="nc" id="L343">				current_m = 0, current_n;</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">		for(int i=0; i&lt;matrixList.length; i++) {</span>
<span class="nc" id="L346">			new_m += matrixList[i].m;</span>
<span class="nc" id="L347">			new_n += matrixList[i].n;</span>
		}

<span class="nc" id="L350">		current_n = new_n;</span>
<span class="nc" id="L351">		Matrix directSum = new Matrix(new_m, new_n);</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">		for(int i=-1; i&lt;matrixList.length; i++) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			if(i==-1) {</span>
<span class="nc" id="L355">				directSum.setSlice(current_m, current_n-A.n, A);</span>
<span class="nc" id="L356">				current_m += A.m;</span>
<span class="nc" id="L357">				current_n -= A.n;</span>
			} else {
<span class="nc" id="L359">				directSum.setSlice(current_m, current_n-matrixList[i].n, matrixList[i]);</span>
<span class="nc" id="L360">				current_m += matrixList[i].m;</span>
<span class="nc" id="L361">				current_n -= matrixList[i].n;</span>
			}
		}

<span class="nc" id="L365">		return directSum;</span>
	}


	/**
	 * Sums the columns of this matrix. If this matrix is an m-by-n matrix, then
	 * @return Given an m-by-n matrix, returns an m-by-1 matrix.
	 */
	default Matrix sumCols() {
<span class="nc" id="L374">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L375">		Matrix colSums = new Matrix(A.m, 1);</span>

<span class="nc bnc" id="L377" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L379">				colSums.entries[i][0] = CNumber.add(colSums.entries[i][0], A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L383">		return colSums;</span>
	}


	/**
	 * Sums the rows of this matrix. If this matrix is an m-by-n matrix, then
	 * @return Given an m-by-n matrix, returns an 1-by-n matrix
	 */
	default Matrix sumRows() {
<span class="nc" id="L392">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L393">		Matrix rowSums = new Matrix(1, A.n);</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L397">				rowSums.entries[0][j] = CNumber.add(rowSums.entries[0][j], A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L401">		return rowSums;</span>
	}


	/**
	 * Sums a column vector to each column of this matrix.
	 *
	 * @param B A matrix which is a column vector.
	 * @return The result of summing a column vector to each column of this matrix.
	 */
	default Matrix sumToEachCol(Matrix B) {
<span class="nc" id="L412">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L413">		Matrix sum = A.copy();</span>

<span class="nc bnc" id="L415" title="All 2 branches missed.">		if(A.m != B.m) {</span>
<span class="nc" id="L416">			throw new IllegalArgumentException(&quot;Matrices must have the same number of rows but got &quot; + A.m + &quot; and &quot; + B.m + &quot;.&quot;);</span>
		}
<span class="nc bnc" id="L418" title="All 2 branches missed.">		if(B.n != 1) {</span>
<span class="nc" id="L419">			throw new IllegalArgumentException(&quot;Argument must be a column vector but got shape &quot; + B.shape + &quot;.&quot;);</span>
		}

<span class="nc bnc" id="L422" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L424">				sum.entries[i][j] = CNumber.add(sum.entries[i][j], B.entries[i][0]);</span>
			}
		}

<span class="nc" id="L428">		return sum;</span>
	}


	/**
	 * Sums a row vector to each row of this matrix.
	 *
	 * @param B A matrix which is a row vector.
	 * @return The result of summing a row vector to each row of this matrix.
	 */
	default Matrix sumToEachRow(Matrix B) {
<span class="nc" id="L439">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L440">		Matrix sum = A.copy();</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">		if(A.n != B.n) {</span>
<span class="nc" id="L443">			throw new IllegalArgumentException(&quot;Matrices must have the same number of columns but got &quot; + A.n + &quot; and &quot; + B.n + &quot;.&quot;);</span>
		}
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if(B.m != 1) {</span>
<span class="nc" id="L446">			throw new IllegalArgumentException(&quot;Argument must be a row vector but got shape &quot; + B.shape + &quot;.&quot;);</span>
		}

<span class="nc bnc" id="L449" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L451">				sum.entries[i][j] = CNumber.add(sum.entries[i][j], B.entries[0][j]);</span>
			}
		}

<span class="nc" id="L455">		return sum;</span>
	}


	/**
	 * Computes element wise square root of the matrix. All square roots are the positive root or, in
	 * the case of complex entries, the root with positive real part.
	 *
	 * @return The element-wise square root of this matrix.
	 */
	default Matrix sqrt() {
<span class="nc" id="L466">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L467">		CNumber[][] root = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L471">				root[i][j] = CNumber.sqrt(A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L475">		return new Matrix(root);</span>
	}


	/**
	 * Computes absolute value, element-wise, of a matrix.
	 * If any of the matrix cells are complex, this will result
	 * in the magnitude of that value.
	 *
	 * @return - element-wise absolute value of matrix.
	 */
	default Matrix abs() {
<span class="nc" id="L487">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L488">		CNumber[][] abs = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L492">				abs[i][j] = CNumber.abs(A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L496">		return new Matrix(abs);</span>
	}


	/**
	 * Transposes Matrix. Same as &lt;code&gt; Matrix.T() &lt;/code&gt;
	 *
	 * @return transpose of matrix
	 */
	default Matrix transpose() {
<span class="nc" id="L506">		return this.T();</span>
	}



	/**
	 * Transposes Matrix. Same as &lt;code&gt; Matrix.transpose() &lt;/code&gt;
	 *
	 * @return transpose of matrix
	 */
	default Matrix T() {
<span class="nc" id="L517">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L518">		CNumber[][] At = new CNumber[A.n][A.m];</span>

<span class="nc" id="L520">		final int BLOCK_SIZE = 16;</span>

		// Compute transpose using blocked algorithm
<span class="nc bnc" id="L523" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i += BLOCK_SIZE) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">			for (int j = 0; j &lt; A.n; j += BLOCK_SIZE) {</span>
				// transpose the block beginning at [i,j]
<span class="nc bnc" id="L526" title="All 4 branches missed.">				for (int k = i; k &lt; i + BLOCK_SIZE &amp;&amp; k &lt; A.m; ++k) {</span>
<span class="nc bnc" id="L527" title="All 4 branches missed.">					for (int l = j; l &lt; j + BLOCK_SIZE &amp;&amp; l &lt; A.n; ++l) {</span>
<span class="nc" id="L528">						At[l][k] = A.entries[k][l];</span>
					}
				}
			}
		}

<span class="nc" id="L534">		return new Matrix(At);</span>
	}


	/**
	 * Conjugates a matrix element-wise.
	 *
	 * @return Conjugate of matrix
	 */
	default Matrix conjugate() {
<span class="nc" id="L544">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L545">		CNumber[][] Ac = new CNumber[A.m][A.n];</span>

<span class="nc bnc" id="L547" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">			for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L549">				Ac[i][j] = CNumber.conjugate(A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L553">		return new Matrix(Ac);</span>
	}


	/**
	 * Computes the conjugate transpose of this matrix.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is the same as {@link #hermAdjoint() hermAdjoint()} and {@link #H() H()}.
	 *
	 * @return The conjugate transpose of this matrix.
	 */
	default Matrix conjT() {
<span class="nc" id="L565">		return this.conjugate().T();</span>
	}


	/**
	 * Computes the Hermation adjoint of a matrix. This is the transpose of the conjugate matrix.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is the same as {@link #conjT() conjT()}  and {@link #H() H()}.
	 *
	 * @return adjoint of matrix.
	 */
	default Matrix hermAdjoint() {
<span class="nc" id="L577">		return this.conjugate().T();</span>
	}


	/**
	 * Computes the Hermation adjoint of a matrix. This is the transpose of the conjugate matrix.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is the same as {@link #conjT() conjT()} and {@link #hermAdjoint() hermAdjpint()}.
	 *
	 * @return adjoint of matrix.
	 */
	default Matrix H() {
<span class="nc" id="L589">		return this.conjugate().T();</span>
	}


	/**
	 * Computes determinant of matrix using reccurisive definition. This method exists
	 * for computing the determinant of non-real matrices.
	 *
	 * @param A - Matrix to compute determinant of
	 * @return determinant of matrix A
	 */
	static CNumber detRec(Matrix A) {
<span class="nc" id="L601">		CNumber value = CNumber.ZERO;</span>

<span class="nc bnc" id="L603" title="All 4 branches missed.">		if(A.m == 1 &amp;&amp; A.n == 1) { // Then we simply have a 1x1 matrix.</span>
<span class="nc" id="L604">			return A.entries[0][0];</span>
		}
<span class="nc bnc" id="L606" title="All 4 branches missed.">		else if(A.m == 2 &amp;&amp; A.n == 2) { // Then we have a 2x2 matrix, which is the base case</span>
<span class="nc" id="L607">			CNumber a = A.entries[0][0];</span>
<span class="nc" id="L608">			CNumber b = A.entries[0][1];</span>
<span class="nc" id="L609">			CNumber c = A.entries[1][0];</span>
<span class="nc" id="L610">			CNumber d = A.entries[1][1];</span>

<span class="nc" id="L612">			value = CNumber.subtract(CNumber.multiply(a, d), CNumber.multiply(b, c));</span>
<span class="nc" id="L613">		}</span>
		else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">			for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L616">				Matrix newA = A.removeRow(0).removeCol(j);</span>

<span class="nc" id="L618">				CNumber num = new CNumber(Math.pow(-1, j));</span>
<span class="nc" id="L619">				num = CNumber.multiply(num, A.entries[0][j]);</span>

<span class="nc" id="L621">				value = CNumber.add(value, CNumber.multiply(detRec(newA), num));</span>
			}
		}

<span class="nc" id="L625">		return value;</span>
	}


	/**
	 * Computes determinant of real matrix using QR decomposition.
	 *
	 * @param A - Matrix to compute determinant of.
	 * @return determinant of matrix A
	 */
	static CNumber detQR(Matrix A) {
<span class="nc" id="L636">		CNumber detQ, detR = CNumber.ONE;</span>
<span class="nc" id="L637">		Matrix[] QRh = Decompose.QR(A, true);</span>

<span class="nc" id="L639">		detQ = new CNumber(Math.pow(-1, QRh[2].entries[0][0].getReal()));</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">		for(int i = 0; i&lt;QRh[1].n; i++) {</span>
<span class="nc" id="L642">			detR = CNumber.multiply(detR, QRh[1].entries[i][i]);</span>
		}

<span class="nc" id="L645">		return CNumber.multiply(detR, detQ);</span>
	}


	/**
	 * Computes determinant of matrix. If the matrix has
	 * any complex entries, this may be a complex value.
	 * Note: Currently this method only works for real matirces.
	 *
	 * @return determinant of matrix.
	 */
	default CNumber det() {
<span class="nc" id="L657">		Matrix A = (Matrix) this;</span>

<span class="nc bnc" id="L659" title="All 2 branches missed.">		if(!A.isSquare()) {</span>
<span class="nc" id="L660">			throw new IllegalArgumentException(&quot;Matrix must be square but got shape &quot; + A.shape);</span>
		}

<span class="nc bnc" id="L663" title="All 4 branches missed.">		if(A.m == 2 &amp;&amp; A.n == 2) { // Then we have a 2x2 matrix, which we can directly compute</span>
<span class="nc" id="L664">			CNumber a = A.entries[0][0];</span>
<span class="nc" id="L665">			CNumber b = A.entries[0][1];</span>
<span class="nc" id="L666">			CNumber c = A.entries[1][0];</span>
<span class="nc" id="L667">			CNumber d = A.entries[1][1];</span>

<span class="nc" id="L669">			return CNumber.subtract(CNumber.multiply(a, d), CNumber.multiply(b, c));</span>
		}

<span class="nc" id="L672">		return detQR(A);</span>
	}


	/**
	 * Stacks matrices along rows. Both matrices must have the same number of columns
	 * Also see {@link #stack(Matrix, int) stack(Matrix B, int axis)}
	 *
	 * @param B
	 * @return
	 */
	default Matrix stack(Matrix B) {
<span class="nc" id="L684">		return this.stack(B, 0);</span>
	}


	/**
	 * Stacks matrices along specified axis. Axis 0 will stack matrices along the rows. Axis 1 will
	 * stack matrices along columns.
	 *
	 * Note: To stack matrices along axis 0 they must have the same number of columns.
	 * To stack matrices along axis 1 they must have the same number of rows.
	 *
	 * @param B - Matrix to stack
	 * @param axis - Axis along which to stack matrices.
	 * @return Returns A and B stacked along specified axis.
	 */
	default Matrix stack(Matrix B, int axis) {
<span class="nc" id="L700">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L701">		Matrix result = null;</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">		if(axis == 0) { // Stack on rows</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">			if(A.entries[0].length != B.entries[0].length) { // Ensure matrices have same number or columns</span>
<span class="nc" id="L705">				throw new IllegalArgumentException(&quot;Must have same number of columns but &quot;</span>
						+ &quot;got &quot; + A.entries[0].length + &quot; and &quot; + B.entries[0].length);
			}

<span class="nc" id="L709">			result = new Matrix(A.entries.length+B.entries.length, A.entries[0].length);</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">			for(int i = 0; i &lt; result.entries.length; i++) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">				for(int j = 0; j &lt; result.entries[0].length; j++) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">					if(i &lt; A.entries.length) { // Then copy from A.entries</span>
<span class="nc" id="L714">						result.entries[i][j] = A.entries[i][j];</span>
					} else { // the copy from B.entries
<span class="nc" id="L716">						result.entries[i][j] = B.entries[i-A.entries.length][j];</span>
					}
				}
			}
		}
<span class="nc bnc" id="L721" title="All 2 branches missed.">		else if(axis == 1) { // Stack on cols</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">			if(A.entries.length != B.entries.length) { // Ensure matrices have same number or rows</span>
<span class="nc" id="L723">				throw new IllegalArgumentException(&quot;Must have same number of rows but &quot;</span>
						+ &quot;got &quot; + A.entries.length + &quot; and &quot; + B.entries.length);
			}

<span class="nc" id="L727">			result = new Matrix(A.entries.length, A.entries[0].length + B.entries[0].length);</span>

<span class="nc bnc" id="L729" title="All 2 branches missed.">			for(int i = 0; i &lt; result.entries.length; i++) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">				for(int j = 0; j &lt; result.entries[0].length; j++) {</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">					if(j &lt; A.entries[0].length) { // Then copy from A.entries</span>
<span class="nc" id="L732">						result.entries[i][j] = A.entries[i][j];</span>
					} else { // the copy from B.entries
<span class="nc" id="L734">						result.entries[i][j] = B.entries[i][j-A.entries[0].length];</span>
					}
				}
			}
		}
		else {
<span class="nc" id="L740">			throw new IllegalArgumentException(&quot;axis must be 0 or 1 but got &quot; + axis);</span>
		}

<span class="nc" id="L743">		return result;</span>
	}


	/**
	 * Augments two matrices. This is the same as {@link #stack(Matrix, int) stack(B, 1)}
	 *
	 * @param B - Matrix to augment to this matrix.
	 * @return The matrix B augmented to this matrix.
	 */
	default Matrix augment(Matrix B) {
<span class="nc" id="L754">		return this.stack(B, 1);</span>
	}


	/**
	 * Computes row-echelon form of matrix. This will be an upper-triangular matrix.&lt;br&gt;
	 *
	 * &lt;pre&gt;
	 * A matrix is in row-echelon form if:
	 *  - The first non-zero element in each row, called the leading entry (also called the pivot), is 1.
	 *  - The pivot of a nonzero row is always strictly to
	 *    the right of the leading coefficient of the row above it.
	 *  - Rows with all zero elements, if any, are below rows having a non-zero element.
	 * &lt;/pre&gt;
	 *
	 * A matrix can be transformed into a row equivalent matrix in row-echelon form using row operations.
	 * This is done using Gaussian (Gauss-Jordan) elimination. &lt;br&gt;&lt;br&gt;
	 *
	 * Also see &lt;code&gt;{@link #rref() rref()}&lt;/code&gt; for reduced row-echelon form.
	 *
	 * @return Row-echelon form of matrix
	 */
	default Matrix ref() {
<span class="nc" id="L777">		Matrix A = ((Matrix) this).copy();</span>
		CNumber m, scale;

<span class="nc" id="L780">		int pivotRow = 0,</span>
<span class="nc" id="L781">				pivotCol = 0;</span>

<span class="nc bnc" id="L783" title="All 4 branches missed.">		while(pivotRow&lt;A.m &amp;&amp; pivotCol&lt;A.n) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">			if(!A.entries[pivotRow][pivotCol].equals(CNumber.ZERO)) { // Then we can make the pivot one.</span>
<span class="nc" id="L785">				scale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);</span>

<span class="nc bnc" id="L787" title="All 2 branches missed.">				for(int k=pivotCol; k&lt;A.n; k++) { // scale the whole row</span>
<span class="nc" id="L788">					A.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale);</span>
				}
			}

<span class="nc bnc" id="L792" title="All 2 branches missed.">			for(int i=pivotRow+1; i&lt;A.m; i++) {</span>
<span class="nc" id="L793">				m = A.entries[i][pivotCol];</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">				for(int k=pivotCol; k&lt;A.n; k++) {</span>
<span class="nc" id="L796">					A.entries[i][k] = CNumber.subtract(A.entries[i][k],</span>
<span class="nc" id="L797">							CNumber.multiply(A.entries[pivotRow][k], m));</span>
				}


				/*
				 * This insures the entries to the left of the pivot are zero.
				 * They may be a very small (in absolute value) non-zero value
				 * resulting from errors in floating point arithmetic.
				 */
<span class="nc" id="L806">				A.entries[i][pivotCol] = CNumber.ZERO;</span>
			}

<span class="nc" id="L809">			pivotRow++;</span>
<span class="nc" id="L810">			pivotCol++;</span>
		}

<span class="nc" id="L813">		return A;</span>
	}


	/**
	 * Computes reduced row-echelon form of matrix.&lt;br&gt;
	 *
	 * &lt;pre&gt;
	 * A matrix is in reduced row-echelon form if:&lt;br&gt;
	 *  - It is in row-echelon form. This is,
	 *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.
	 *      ~ The pivot of a nonzero row is always strictly to
	 *        the right of the leading coefficient of the row above it.
	 *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.&lt;br&gt;
	 *  - The pivot in each row is the only non-zero entry in its column.
	 * &lt;/pre&gt;
	 *
	 * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.
	 * This is done using Gaussian (Gauss-Jordan) elimination. &lt;br&gt;&lt;br&gt;
	 *
	 * @param partialPivoting - Falg for use of partial pivoting.
	 * &lt;pre&gt;
	 *  - If true then the rref will be computed using partial pivoting.
	 * 	    ~ This is equivalent to the method {@link #rref() rref()}.
	 *  - If false then the rref will be computed WITHOUT using partial pivoting.
	 * &lt;/pre&gt;
	 * @return
	 */
	default Matrix rref(boolean partialPivoting) {
<span class="nc bnc" id="L842" title="All 2 branches missed.">		if(partialPivoting) return rref();</span>
<span class="nc" id="L843">		else return rrefNoPivot();</span>
	}


	/**
	 * Computes reduced row-echelon form of matrix. This is done using partial pivoting.&lt;br&gt;
	 *
	 * &lt;pre&gt;
	 * A matrix is in reduced row-echelon form if:&lt;br&gt;
	 *  - It is in row-echelon form. This is,
	 *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.
	 *      ~ The pivot of a nonzero row is always strictly to
	 *        the right of the leading coefficient of the row above it.
	 *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.&lt;br&gt;
	 *  - The pivot in each row is the only non-zero entry in its column.
	 * &lt;/pre&gt;
	 *
	 * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.
	 * This is done using Gaussian (Gauss-Jordan) elimination. &lt;br&gt;&lt;br&gt;
	 *
	 * Also see &lt;code&gt;{@link #ref() ref()}&lt;/code&gt; for row-echelon form.
	 *
	 * @return Row-echelon form of matrix.
	 */
	default Matrix rref() {
<span class="nc" id="L868">		Matrix A = ((Matrix) this).copy();</span>
		CNumber mult, scale, currentMax;
		int maxIndex;

<span class="nc" id="L872">		int pivotRow = 0,</span>
<span class="nc" id="L873">				pivotCol = 0;</span>

<span class="nc bnc" id="L875" title="All 4 branches missed.">		while(pivotRow&lt;A.m &amp;&amp; pivotCol&lt;A.n) {</span>
<span class="nc" id="L876">			maxIndex = pivotRow;</span>
<span class="nc" id="L877">			currentMax = A.entries[pivotRow][pivotCol];</span>

<span class="nc bnc" id="L879" title="All 2 branches missed.">			for(int i=pivotRow; i&lt;A.m; i++) { // Find the maximum entry in the pivot column (at or below the pivot ).</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">				if(A.entries[i][pivotCol].nearZero(1.0E-12)) {</span>

					/*
					 * If a number is very close to zero, assume it is supposed to be zero.
					 * This protects against trying to manipulate a column which
					 * is already in the correct form.
					 */
<span class="nc" id="L887">					A.entries[i][pivotCol] = CNumber.ZERO;</span>
				}
<span class="nc bnc" id="L889" title="All 2 branches missed.">				else if(A.entries[i][pivotCol].compareTo(currentMax) &gt; 0) {</span>
<span class="nc" id="L890">					maxIndex = i;</span>
<span class="nc" id="L891">					currentMax = A.entries[i][pivotCol];</span>
				}
			}

<span class="nc bnc" id="L895" title="All 2 branches missed.">			if(!A.entries[maxIndex][pivotCol].equals(CNumber.ZERO)) { // Check that the maximum absolute value is not zero.</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">				if(pivotRow != maxIndex) {</span>
<span class="nc" id="L897">					A = A.swapRows(pivotRow, maxIndex); // Make the row with the largest value in the pivot column the pivot for this row.</span>
				}

<span class="nc" id="L900">				scale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);</span>

<span class="nc bnc" id="L902" title="All 2 branches missed.">				for(int k=pivotCol; k&lt;A.n; k++) { // scale the whole row so that the pivot is 1</span>
<span class="nc" id="L903">					A.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale);</span>
				}

<span class="nc bnc" id="L906" title="All 2 branches missed.">				for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L907">					mult = A.entries[i][pivotCol];</span>

<span class="nc bnc" id="L909" title="All 2 branches missed.">					if(pivotRow != i) {</span>
<span class="nc" id="L910">						A.entries[i][pivotCol] = CNumber.ZERO;</span>

<span class="nc bnc" id="L912" title="All 2 branches missed.">						for(int k=pivotCol+1; k&lt;A.n; k++) {</span>

<span class="nc" id="L914">							CNumber value = CNumber.subtract(A.entries[i][k],</span>
<span class="nc" id="L915">									CNumber.multiply(A.entries[pivotRow][k], mult));</span>
<span class="nc" id="L916">							A.entries[i][k] = value;</span>
						}

					}
				}

<span class="nc" id="L922">				pivotRow++;</span>
<span class="nc" id="L923">				pivotCol++;</span>
			}
			else { // Then we do not have a pivot for this column (i.e. the column is all zeros).
<span class="nc" id="L926">				pivotCol++;</span>
			}
		}

<span class="nc" id="L930">		return A;</span>
	}


	/**
	 * Computes reduced row-echelon form of matrix.
	 * This is done WITHOUT using partial pivoting.&lt;br&gt;
	 *
	 * &lt;pre&gt;
	 * A matrix is in reduced row-echelon form if:&lt;br&gt;
	 *  - It is in row-echelon form. This is,
	 *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.
	 *      ~ The pivot of a nonzero row is always strictly to
	 *        the right of the leading coefficient of the row above it.
	 *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.&lt;br&gt;
	 *  - The pivot in each row is the only non-zero entry in its column.
	 * &lt;/pre&gt;
	 *
	 * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.
	 * This is done using Gaussian (Gauss-Jordan) elimination. &lt;br&gt;&lt;br&gt;
	 *
	 * Also see &lt;code&gt;{@link #ref() ref()}&lt;/code&gt; for row-echelon form.
	 *
	 * @return Row-echelon form of matrix.
	 */
	default Matrix rrefNoPivot() {
<span class="nc" id="L956">		Matrix A = ((Matrix) this).copy();</span>
		CNumber m, scale;

<span class="nc" id="L959">		int pivotRow = 0,</span>
<span class="nc" id="L960">				pivotCol = 0;</span>

<span class="nc bnc" id="L962" title="All 4 branches missed.">		while(pivotRow&lt;A.m &amp;&amp; pivotCol&lt;A.n) {</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">			if(!A.entries[pivotRow][pivotCol].equals(CNumber.ZERO)) {</span>
<span class="nc" id="L964">				scale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">				for(int k=pivotCol; k&lt;A.n; k++) { // scale the whole row</span>
<span class="nc" id="L967">					A.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale);</span>
				}
			}

<span class="nc bnc" id="L971" title="All 2 branches missed.">			for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L972">				m = A.entries[i][pivotCol];</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">				if(pivotRow != i) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">					for(int k=pivotCol; k&lt;A.n; k++) {</span>
<span class="nc" id="L976">						A.entries[i][k] = CNumber.subtract(A.entries[i][k],</span>
<span class="nc" id="L977">								CNumber.multiply(A.entries[pivotRow][k], m));</span>
					}
				}
			}

<span class="nc" id="L982">			pivotRow++;</span>
<span class="nc" id="L983">			pivotCol++;</span>
		}

<span class="nc" id="L986">		return A;</span>
	}


	/**
	 * Computes reduced extended row-echelon form of matrix. That is, a Matrix with
	 * the same number of rows is {@link #augment(Matrix) augmented} with this matrix and
	 * then this augmented matrix is put into {@link #rref() reduced row-echelon form}.
	 *
	 * @return Returns extended row-echelon form of this matrix.
	 */
	default Matrix erref() {
<span class="nc" id="L998">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L999">		Matrix I = Matrix.I(A.m);</span>
<span class="nc" id="L1000">		Matrix Aug = A.augment(I);</span>

<span class="nc" id="L1002">		return Aug.rref();</span>
	}


	/**
	 * Computes the trace of square matrix. That is, the sum
	 * of the entries along the principle diagonal.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is the same as {@link #tr() tr()}.
	 *
	 * @return trace of this matrix.
	 */
	default CNumber trace() {
<span class="nc" id="L1015">		Matrix A = (Matrix) this;</span>

<span class="nc bnc" id="L1017" title="All 2 branches missed.">		if(!A.isSquare()) {</span>
<span class="nc" id="L1018">			throw new IllegalArgumentException(&quot;Expecting matrix to be square but got &quot; + A.shape);</span>
		}

<span class="nc" id="L1021">		CNumber result = A.entries[0][0];</span>

<span class="nc bnc" id="L1023" title="All 2 branches missed.">		for(int i = 1; i &lt; A.n; i++) {</span>
<span class="nc" id="L1024">			result = CNumber.add(result, A.entries[i][i]);</span>
		}

<span class="nc" id="L1027">		return result;</span>
	}


	/**
	 * Computes the trace of a square matrix. That is, the sum
	 * of the entries along the principle diagonal.
	 * &lt;br&gt;&lt;br&gt;
	 * This method is the same as {@link #trace() trace()}.
	 *
	 * @return trace of this matrix.
	 */
	default CNumber tr() {
<span class="nc" id="L1040">		return this.trace();</span>
	}


	/**
	 * The rank of a matrix A is the dimension of the vector space generated (or spanned) by its columns.
	 * This is always an integer.
	 * This corresponds to the maximal number of linearly independent columns of A.
	 * This, in turn, is identical to the dimension of the vector space spanned by its rows
	 *
	 * @return Returns the rank of this matrix.
	 */
	// TODO: Should be switched to rank revealing QR decomposition as it is more numerically stable.
	default int rank() {
<span class="nc" id="L1054">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L1055">		Matrix rrefA = A.rref();</span>
<span class="nc" id="L1056">		int rank = A.m;</span>

<span class="nc bnc" id="L1058" title="All 2 branches missed.">		for(int i=rrefA.m-1; i&gt;=0; i--) {</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">			if(rrefA.getRowAsVector(i).isZero()) {</span>
<span class="nc" id="L1060">				rank--;</span>
			} else {
				// Then we have no more zero rows as rrefA is in reduced row echelon form.
				break;
			}
		}

<span class="nc" id="L1067">		return rank;</span>
	}


	/**
	 * The rank of a matrix A is the dimension of the vector space spanned by the nullspace of this matrix.
	 * The nullify is always an integer.
	 *
	 * @return Returns the rank of this matrix.
	 */
	default int nullity() {
<span class="nc" id="L1078">		int rank = this.rank();</span>
<span class="nc" id="L1079">		return ((Matrix) this).m - rank;</span>
	}


	/**
	 * Computes the matrix inverse if it exists. This is done by first computing the {@link linalg.Decompose#QR(Matrix) QR decomposition}
	 * The inverse of a Matrix A is A&lt;sup&gt;-1&lt;/sup&gt; satisfying AA&lt;sup&gt;-1&lt;/sup&gt;=I where I is the appropriately sized Identity matrix.
	 *
	 * @return The inverse of this matrix.
	 */
	default Matrix inverse() {
<span class="nc" id="L1090">		Matrix A = (Matrix) this;</span>

<span class="nc bnc" id="L1092" title="All 2 branches missed.">		if(!A.isSingular()) {</span>
<span class="nc" id="L1093">			throw new IllegalArgumentException(&quot;Matrix is singular.&quot;);</span>
		}

<span class="nc" id="L1096">		Matrix[] QR = Decompose.QR(A); // Compute the QR decomposition of A. This will be used to compute the inverse.</span>
<span class="nc" id="L1097">		CNumber detR = CNumber.ONE;</span>

<span class="nc bnc" id="L1099" title="All 2 branches missed.">		for(int i = 0; i&lt;QR[1].n; i++) { // Computing the determinant of R</span>
<span class="nc" id="L1100">			detR = CNumber.multiply(detR, QR[1].entries[i][i]);</span>
		}

<span class="nc bnc" id="L1103" title="All 2 branches missed.">		if(CNumber.round(detR, 10).re == 0) {</span>
			/* Then we know the matrix is singular.
			 * We know this by exploiting properties of the orthogonal matrix Q and the upper triangular matrix R.
			 * The determinant of an orthogonal matrix is either -1 or 1. The determinant of an upper triangular matrix R is the product
			 * of the diagonals. Since A=QR det(A) = det(QR) = det(Q)*det(R). So if the determinant of R is zero, then the matrix A must be singular.
			 *
			 * The isSingular() method is not used here because it computes the QR decomposition to check if the matrix is singular. However, we have already done that,
			 * so it would be redundant to call the isSingular() method and recompute the QR decomposition again.
			 */
<span class="nc" id="L1112">			throw new IllegalArgumentException(&quot;Matrix is singular, thus can not be inverted.&quot;);</span>
		}

		// Here we compute and return A^-1 = (R^-1)*(Q^-1)
<span class="nc" id="L1116">		return inverseTriU(QR[1]).mult(QR[0].H());</span>
	}


	/**
	 * Computes the matrix inverse if it exists. This is done by first computing the {@link linalg.Decompose#QR(Matrix) QR decomposition}
	 * The inverse of a Matrix A is A&lt;sup&gt;-1&lt;/sup&gt; satisfying AA&lt;sup&gt;-1&lt;/sup&gt;=I where I is the appropriately sized Identity matrix.
	 *
	 * @return The inverse of this matrix.
	 */
	default Matrix inv() {
<span class="nc" id="L1127">		return this.inverse();</span>
	}


	/**
	 * Helper method to invert an upper triangular matrix. &lt;br&gt;
	 * We can compute the inverse of an n-by-n upper triangular matrix U by solving the n systems...&lt;br&gt;&lt;br&gt;
	 *
	 * Ux=I&lt;sub&gt;i&lt;/sub&gt;&lt;br&gt;
	 *
	 * where 1&lt;=i&lt;=n, I is the n-by-n identity matrix, I&lt;sub&gt;i&lt;/sub&gt; is the ith column of I.&lt;br&gt;&lt;br&gt;
	 *
	 * Each solution becomes a column in the inverse &lt;sup&gt;-1&lt;/sub&gt;.
	 * Because U is upper triangular, we can solve these n systems using backsolve.
	 *
	 * @param U - U is a square upper triangular matrix
	 * @return Returns the inverse of U, denoted U&lt;sup&gt;-1&lt;/sub&gt;
	 */
	static Matrix inverseTriU(Matrix U) {
<span class="nc" id="L1146">		Matrix Uinv = new Matrix(U.m, U.m);</span>
<span class="nc" id="L1147">		Matrix I = Matrix.I(U.m);</span>

<span class="nc bnc" id="L1149" title="All 2 branches missed.">		if(!U.isTriU()) {</span>
<span class="nc" id="L1150">			throw new IllegalArgumentException(&quot;U must be upper triangular.&quot;);</span>
		}

<span class="nc bnc" id="L1153" title="All 2 branches missed.">		for(int i=0; i&lt;U.m; i++)  {</span>
			// U is upper triangular, so to solve the system we simply need to use back-solve function.
<span class="nc" id="L1155">			Uinv.setCol(Solvers.backSolve(U, I.getColAsVector(i)), i);</span>
		}

<span class="nc" id="L1158">		return Uinv;</span>
	}


	/**
	 * Creates a new matrix that contains the reciprocals of this matrix
	 *
	 * @return new matrix that contains the reciprocals of this matrix
	 */
	default Matrix recep() {
<span class="nc" id="L1168">		Matrix A = new Matrix((Matrix) this).copy();</span>

<span class="nc bnc" id="L1170" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L1172">				A.entries[i][j] = CNumber.inv(A.entries[i][j]);</span>
			}
		}

<span class="nc" id="L1176">		return A;</span>
	}

	public static void main(String[] args) {
<span class="nc" id="L1180">		double[][] a = {{1}, {4}, {7}};</span>
<span class="nc" id="L1181">		double[] b = {0.1, 0.2, 0.3};</span>

<span class="nc" id="L1183">		Matrix A = new Matrix(a);</span>
<span class="nc" id="L1184">		Matrix B = new Vector(b);</span>

<span class="nc" id="L1186">		Matrix.println(A.sumToEachCol(B));</span>
<span class="nc" id="L1187">	}</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>