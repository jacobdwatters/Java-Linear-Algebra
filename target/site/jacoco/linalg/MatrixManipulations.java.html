<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatrixManipulations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java-Linear-Algebra</a> &gt; <a href="index.source.html" class="el_package">linalg</a> &gt; <span class="el_source">MatrixManipulations.java</span></div><h1>MatrixManipulations.java</h1><pre class="source lang-java linenums">package linalg;

import linalg.complex_number.CNumber;
import linalg.util.LinAlgArrayUtils;
import linalg.util.Parser;

/**
 * This interface provides several methods useful for matrix manipulations and is
 * Implemented by the Matrix class.
 * 
 * @author Jacob Watters
 */
// TODO: Many methods in this class should probably manipulate the instance object and have void return.
 interface MatrixManipulations {
	
	
	 default Matrix reshape(String newShape) {
<span class="nc" id="L18">		int[] dimensions = Parser.parseShape(newShape);</span>
<span class="nc" id="L19">		int 	newM = dimensions[0],</span>
<span class="nc" id="L20">				newN = dimensions[1];</span>
		
<span class="nc" id="L22">		return this.reshape(newM, newN);</span>
	}
	
	
	 default Matrix reshape(int newM, int newN) {
<span class="nc" id="L27">		Matrix A = ((Matrix) this).flatten();</span>
<span class="nc" id="L28">		Matrix reshape = new Matrix(newM, newN);</span>
<span class="nc" id="L29">		int aj=0;</span>

<span class="nc bnc" id="L31" title="All 2 branches missed.">		if(newM*newN != A.m*A.n) {</span>
<span class="nc" id="L32">			throw new IllegalArgumentException(&quot;Can not reshape matrix of shape &quot; + A.shape + &quot; to &quot; + newM + &quot;x&quot; + newN + &quot;.&quot;);</span>
		}


<span class="nc bnc" id="L36" title="All 2 branches missed.">		for(int i=0; i&lt;reshape.m; i++) {</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">			for(int j=0; j&lt;reshape.n; j++) {</span>
<span class="nc" id="L38">				reshape.entries[i][j] = new CNumber(A.entries[0][aj]);</span>
<span class="nc" id="L39">				aj++;</span>
			}
		}
		
				
<span class="nc" id="L44">		return reshape;</span>
	}
	
	
	/**
	 * Flattens an &lt;code&gt;MxN&lt;/code&gt; matrix to a 1x(m*n) matrix.
	 * Each row of the Matrix is appended to the end
	 * of the first row of the Matrix in order.
	 * 
	 * @return 
	 */
	 default Matrix flatten() {
<span class="nc" id="L56">		Matrix A = (Matrix) this,</span>
				flat;
<span class="nc" id="L58">		int count = 0;</span>

<span class="nc" id="L60">		CNumber[][] flat_A = new CNumber[1][A.m*A.n];</span>
		
<span class="nc bnc" id="L62" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">			for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L64">				flat_A[0][count] = A.entries[i][j];</span>
<span class="nc" id="L65">				count++;</span>
			}
		}
		
<span class="nc" id="L69">		flat = new Matrix(flat_A);</span>
		
<span class="nc" id="L71">		return flat;</span>
	}
	
	
	/**
	 * Flattens an &lt;code&gt;MxN&lt;/code&gt; matrix to a 1x(m*n) or (m*n)x1 matrix depending on axis.
	 *
	 * @param axis - axis along which to flatten
	 * @return 
	 */
	 default Matrix flatten(int axis) {
<span class="nc" id="L82">		Matrix A = (Matrix) this,</span>
				flat;
		
<span class="nc bnc" id="L85" title="All 2 branches missed.">		if(axis == 0) {</span>
<span class="nc" id="L86">			flat = A.flatten();</span>
		}
<span class="nc bnc" id="L88" title="All 2 branches missed.">		else if(axis == 1) {	</span>
<span class="nc" id="L89">			int count = 0;</span>

<span class="nc" id="L91">			CNumber[][] flat_A = new CNumber[A.m*A.n][1];</span>
			
<span class="nc bnc" id="L93" title="All 2 branches missed.">			for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">				for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L95">					flat_A[count][0] = A.entries[i][j];</span>
<span class="nc" id="L96">					count++;</span>
				}
			}
			
<span class="nc" id="L100">			flat = new Matrix(flat_A);</span>
<span class="nc" id="L101">		}</span>
		else {
<span class="nc" id="L103">			throw new IllegalArgumentException(&quot;axis must be 0 or 1 but got &quot; + axis);</span>
		}
		
<span class="nc" id="L106">		return flat;</span>
	}


	/**
	 * Extends a row or column vector to form a matrix. That is, for a row vector,
	 *
	 * @param n Number of times to make the extension. That is, for a row vector with m entries, a matrix of shape
	 *          n-by-m will be formed. For a column vector with m entries, a matrix of shape m-by-n will be formed.
	 *
	 * @return The extended matrix formed from the vector.
	 * @throws IllegalCallerException if the caller is not a {@link Vector}
	 */
	default Matrix extend(int n) {
<span class="nc" id="L120">		Matrix v = (Matrix) this;</span>
		Matrix extended;

<span class="nc bnc" id="L123" title="All 4 branches missed.">		if(!(v.m==1 || v.n==1)) {</span>
<span class="nc" id="L124">			throw new IllegalCallerException(&quot;This matrix is not a Vector.&quot;);</span>
		}

<span class="nc bnc" id="L127" title="All 2 branches missed.">		if(v.vectorType() == Vector.COLUMN_VECTOR) {</span>
<span class="nc" id="L128">			extended = new Matrix(v.numRows(), n);</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">			for(int i=0; i&lt;extended.numRows(); i++) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">				for(int j=0; j&lt;extended.numCols(); j++) {</span>
<span class="nc" id="L132">					extended.entries[i][j] = v.get(i, 0);</span>
				}
			}

		} else {
<span class="nc" id="L137">			extended = new Matrix(n, v.numCols());</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">			for(int i=0; i&lt;n; i++) {</span>
<span class="nc" id="L140">				extended.entries[i] = v.getRow(0);</span>
			}
		}

<span class="nc" id="L144">		return extended;</span>
	}


	/**
	 * Copies values from array into matrix. The given array must have the same dimensions
	 * as the matrix object. This will replace any current values in the matrix.
	 * 
	 *  @param values - Values to copy into array
	 */
	 default void setValues(CNumber[][] values) {
<span class="nc" id="L155">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L157" title="All 4 branches missed.">		if(values.length != A.entries.length || values[0].length != A.entries[0].length) {</span>
<span class="nc" id="L158">			throw new IllegalArgumentException(&quot;Expecting array with shape &quot; + A.shape + </span>
					&quot; but got array with shape &quot; + values.length + &quot;x&quot; + values[0].length + &quot;.&quot;);
		}
		
<span class="nc" id="L162">		A.entries = values;</span>
<span class="nc" id="L163">	}</span>
	
	
	/**
	 * Copies values from array into matrix. The given array must have the same dimensions
	 * as the matrix object. A will replace any current values in the matrix.
	 * 
	 *  @param values - Values to copy into array
	 */
	 default void setValues(double[][] values) {
<span class="nc" id="L173">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L175" title="All 4 branches missed.">		if(values.length != A.entries.length || values[0].length != A.entries[0].length) {</span>
<span class="nc" id="L176">			throw new IllegalArgumentException(&quot;Expecting array with shape &quot; + A.shape + </span>
					&quot; but got array with shape &quot; + values.length + &quot;x&quot; + values[0].length + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L180" title="All 2 branches missed.">		for(int i = 0; i &lt; A.entries.length; i++) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">			for(int j = 0; j &lt; A.entries[0].length; j++) {</span>
<span class="nc" id="L182">				A.entries[i][j] = new CNumber(values[i][j]);</span>
			}
		}
<span class="nc" id="L185">	}</span>
	
	
	/**
	 * Sets specified element in matrix to value. A will replace the current value
	 * at that index.
	 *
	 * @param value - value to insert into matrix
	 * @param row - row to insert value
	 * @param col - column to insert value
	 */
	 default void set(CNumber value, int row, int col) {
<span class="nc" id="L197">		Matrix A = (Matrix) this;</span>
		
<span class="nc" id="L199">		A.entries[row][col] = value;</span>
<span class="nc" id="L200">	}</span>
	
	
	/**
	 * Sets specified element in matrix to value. A will replace the current value
	 * at that index.
	 *
	 * @param value - value to insert into matrix
	 * @param row - row index to insert value
	 * @param col - column index to insert value
	 */
	 default void set(double value, int row, int col) {
<span class="nc" id="L212">		Matrix A = (Matrix) this;</span>
		
<span class="nc" id="L214">		A.entries[row][col] = new CNumber(value);</span>
<span class="nc" id="L215">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed column vector.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see &lt;br&gt;
	 * {@link #setCol(CNumber[], int) setCol(CNumber[] col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(double[], int) setCol(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the vector is not a column vector or if the vector and matrix do not
	 * 	have the same number of rows.
	 * @param col - Column vector containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(Vector col, int colIndex) {
<span class="nc" id="L231">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if(col.vectorType() != Vector.COLUMN_VECTOR) {</span>
<span class="nc" id="L234">			throw new IllegalArgumentException(&quot;Vector must be column vector.&quot;); // TODO: Add vectorTypeAsString();</span>
		}
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if(col.m != A.m) {</span>
<span class="nc" id="L237">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with a vector of shape &quot; + col.shape);</span>
		}
		
<span class="nc bnc" id="L240" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L241">			A.entries[i][colIndex] = col.get(i, 0);</span>
		}
<span class="nc" id="L243">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setCol(Vector, int) setCol(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(double[], int) setCol(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of rows in the matrix.
	 * @param col - array containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(CNumber[] col, int colIndex) {
<span class="nc" id="L258">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L260" title="All 2 branches missed.">		if(col.length != A.m) {</span>
<span class="nc" id="L261">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + col.length);</span>
		}
		
<span class="nc bnc" id="L264" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L265">			A.entries[i][colIndex] = new CNumber(col[i]);</span>
		}
<span class="nc" id="L267">	}</span>
	
	
	/**
	 * Sets specified column of this matrix to the values stored within the passed array.
	 * Also see&lt;br&gt;
	 * {@link #setCol(Vector, int) setCol(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setCol(CNumber[], int) setCol(CNumber[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of rows in the matrix.
	 * @param col - array containing the new entries for the specified column.
	 * @param colIndex - Index of new column to set. 
	 */
	 default void setCol(double[] col, int colIndex) {
<span class="nc" id="L281">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if(col.length != A.m) {</span>
<span class="nc" id="L284">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + col.length);</span>
		}
		
<span class="nc bnc" id="L287" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc" id="L288">			A.entries[i][colIndex] = new CNumber(col[i]);</span>
		}
<span class="nc" id="L290">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed row vector.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see &lt;br&gt;
	 * {@link #setRow(CNumber[], int) setRow(CNumber[] col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(double[], int) setRow(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the vector is not a row vector or if the vector and matrix do not
	 * 	have the same number of columns.
	 * @param row - row vector containing the new entries for the specified column.
	 * @param rowIndex - Index of new row to set. 
	 */
	 default void setRow(Vector row, int rowIndex) {
<span class="nc" id="L306">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L308" title="All 2 branches missed.">		if(row.vectorType() != Vector.ROW_VECTOR) {</span>
<span class="nc" id="L309">			throw new IllegalArgumentException(&quot;Vector must be row vector.&quot;); // TODO: Add vectorTypeAsString();</span>
		}
<span class="nc bnc" id="L311" title="All 2 branches missed.">		if(row.n != A.n) {</span>
<span class="nc" id="L312">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with a vector of shape &quot; + row.shape);</span>
		}
		
<span class="nc bnc" id="L315" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L316">			A.entries[rowIndex][i] = row.get(0, i);</span>
		}
<span class="nc" id="L318">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setRow(Vector, int) setRow(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(double[], int) setRow(double[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of columns in the matrix.
	 * @param row - array containing the new entries for the specified column.
	 * @param rowIndex - Index of new column to set. 
	 */
	 default void setRow(CNumber[] row, int rowIndex) {
<span class="nc" id="L333">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if(row.length != A.n) {</span>
<span class="nc" id="L336">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + row.length);</span>
		}
		
<span class="nc bnc" id="L339" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L340">			A.entries[rowIndex][i] = new CNumber(row[i]);</span>
		}
<span class="nc" id="L342">	}</span>
	
	
	/**
	 * Sets specified row of this matrix to the values stored within the passed array.
	 * &lt;br&gt;&lt;br&gt;
	 * Also see&lt;br&gt;
	 * {@link #setRow(Vector, int) setRow(Vector col, int colIndex)}&lt;br&gt;
	 * {@link #setRow(CNumber[], int) setRow(CNumber[] col, int colIndex)}
	 * 
	 * @throws IllegalArgumentException if the array of values has a different length then the number of columns in the matrix.
	 * @param row - array containing the new entries for the specified column.
	 * @param rowIndex - Index of new column to set. 
	 */
	 default void setRow(double[] row, int rowIndex) {
<span class="nc" id="L357">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L359" title="All 2 branches missed.">		if(row.length != A.n) {</span>
<span class="nc" id="L360">			throw new IllegalArgumentException(&quot;Can not set column for matrix of shape &quot; + A.shape + &quot; with array of length &quot; + row.length);</span>
		}
		
<span class="nc bnc" id="L363" title="All 2 branches missed.">		for(int i=0; i&lt;A.n; i++) {</span>
<span class="nc" id="L364">			A.entries[rowIndex][i] = new CNumber(row[i]);</span>
		}
<span class="nc" id="L366">	}</span>
	
	
	/**
	 * Creates a copy of this matrix and sets a specified slice of the copy to the values stored in the &lt;code&gt;values&lt;/code&gt; matrix. Together
	 * the parameters &lt;code&gt;rowStart&lt;/code&gt; and &lt;code&gt;colStart&lt;/code&gt; define the upper left corner of the 
	 * slice to set.&lt;br&gt;&lt;br&gt;
	 * 
	 * If the values matrix does not fit within this matrix, an error will be thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * If want to adjust this matrix instance directly see {@link #setSlice(int, int, Matrix) setSlice(Matrix values, int rowStart, int colStart)}
	 * 
	 * @return
	 */
	 default Matrix setSliceCopy(int rowStart, int colStart, Matrix values) {
<span class="nc" id="L381">		Matrix A = ((Matrix) this).copy();</span>
		
<span class="nc bnc" id="L383" title="All 4 branches missed.">		if(values.m + rowStart &gt; A.m || values.n + colStart &gt; A.n) {</span>
<span class="nc" id="L384">			throw new IllegalArgumentException(&quot;Values do not fit in matrix. Attempting to set values of shape &quot; + values.shape +</span>
					&quot; with offset of (&quot; + rowStart + &quot;, &quot; + colStart + &quot;) in a matrix of shape &quot; + A.shape + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L388" title="All 2 branches missed.">		for(int i=rowStart; i&lt;values.m + rowStart; i++) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">			for(int j=colStart; j&lt;values.n + colStart; j++) {</span>
<span class="nc" id="L390">				A.entries[i][j] = values.entries[i-rowStart][j-colStart];</span>
			}
		}
		
<span class="nc" id="L394">		return A;</span>
	}
	
	
	/**
	 * Sets a specified slice of this matrix to the values stored in the &lt;code&gt;values&lt;/code&gt; matrix. Together
	 * the parameters &lt;code&gt;rowStart&lt;/code&gt; and &lt;code&gt;colStart&lt;/code&gt; define the upper left corner of the 
	 * slice to set.&lt;br&gt;&lt;br&gt;
	 * 
	 * If the values matrix does not fit within this matrix, an error will be thrown.
	 * &lt;br&gt;&lt;br&gt;
	 * If you do not want to adjust this matrix instance see {@link #setSliceCopy(int, int, Matrix) setSliceCopy(Matrix values, int rowStart, int colStart)}
	 * @param rowStart - Row on original matrix to place top row of values matrix
	 * @param colStart - Column on original matrix to place left-most column of values matrix
	 * @param values - New values to set within specified slice.
	 */
	 default void setSlice(int rowStart, int colStart, Matrix values) {
<span class="nc" id="L411">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L413" title="All 4 branches missed.">		if(values.m + rowStart &gt; A.m || values.n + colStart &gt; A.n) {</span>
<span class="nc" id="L414">			throw new IllegalArgumentException(&quot;Values do not fit in matrix. Attempting to set values of shape &quot; + values.shape +</span>
					&quot; with offset of (&quot; + rowStart + &quot;, &quot; + colStart + &quot;) in a matrix of shape &quot; + A.shape + &quot;.&quot;);
		}
		
<span class="nc bnc" id="L418" title="All 2 branches missed.">		for(int i=rowStart; i&lt;values.m + rowStart; i++) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">			for(int j=colStart; j&lt;values.n + colStart; j++) {</span>
<span class="nc" id="L420">				A.entries[i][j] = values.entries[i-rowStart][j-colStart];</span>
			}
		}
<span class="nc" id="L423">	}</span>
	
	
	/**
	 * Removes specified single row from matrix.
	 * 
	 * To remove more than one row at a time
	 * see {@link #removeRows(int...) removeRows(int... rowIndices)}.
	 * 
	 * @param rowIndex - Index of row to remove.
	 * @return Matrix with the specified row removed.
	 */
	 default Matrix removeRow(int rowIndex) {
<span class="nc" id="L436">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L437">		return A.removeRows(rowIndex);</span>
	}
	
	
	/**
	 * Removes specified rows from matrix. If k row indices are specified for 
	 * a mxn matrix, the resulting matrix will have shape (m-k)xn. 
	 * 
	 * Also see {@link #removeRow(int) removeRow(int rowIndex)}.
	 * 
	 * @param rowIndices - list of row indices to remove from matrix.
	 * @return Matrix with specified rows removed
	 */
	 default Matrix removeRows(int... rowIndices) {
<span class="nc" id="L451">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L452">		Matrix result = new Matrix(A.m-(rowIndices.length), A.n);</span>
		
<span class="nc" id="L454">		int newi = 0;</span>
		
<span class="nc bnc" id="L456" title="All 2 branches missed.">		for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">			if(!LinAlgArrayUtils.contains(rowIndices, i)) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">				for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc" id="L459">					result.entries[newi][j] = A.entries[i][j];</span>
				}
<span class="nc" id="L461">				newi++;</span>
			}
		}
		
<span class="nc" id="L465">		return result;</span>
	}
	
	
	/**
	 * Removes specified single column from matrix.
	 * 
	 * To remove more than one column at a time
	 * see {@link #removeCols(int...) removeCols(int... colIndices)}.
	 * 
	 * @param colIndex - Index of column to remove.
	 * @return Matrix with the specified column removed.
	 */
	 default Matrix removeCol(int colIndex) {
<span class="nc" id="L479">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L480">		return A.removeCols(colIndex);</span>
	}
	
	
	/**
	 * Removes specified columns from matrix. If k column indices are specified for 
	 * a mxn matrix, the resulting matrix will have shape m-by-(n-k).
	 *
	 * Also see {@link #removeCol(int) removeCol(int colIndex)}
	 * 
	 * @param colIndices - list of column indices to remove from matrix.
	 * @return Matrix with specified columns removed
	 */
	 default Matrix removeCols(int... colIndices) {
<span class="nc" id="L494">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L495">		Matrix result = new Matrix(A.m, A.n-(colIndices.length));</span>
		
<span class="nc" id="L497">		int newj = 0;</span>
		
<span class="nc bnc" id="L499" title="All 2 branches missed.">		for(int j = 0; j &lt; A.n; j++) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">			if(!LinAlgArrayUtils.contains(colIndices, j)) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">				for(int i = 0; i &lt; A.m; i++) {</span>
<span class="nc" id="L502">					result.entries[i][newj] = A.entries[i][j];</span>
				}
<span class="nc" id="L504">				newj++;</span>
			}
		}
		
<span class="nc" id="L508">		return result;</span>
	}
	
	
	/**
	 * Generates lower triangle of Matrix. That is, all values above the middle
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #tril(int) tril(int k)}&lt;/code&gt;
	 * 
	 * @return Lower triangle of Matrix.
	 */
	 default Matrix tril() {
<span class="nc" id="L521">		return this.tril(0);</span>
	}
	
	
	/**
	 * Generates lower triangle of Matrix. That is, all values above the kth
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #tril(int) tril()}&lt;/code&gt;
	 * 
	 * @param k - diagonal above which to zero. k=0 whould be middile diagonal, k=-1 would be 
	 * 	the diagonal to the left of the middle diagonal, and k=1 would be the diagonal to the right
	 * 	of the middle diagonal.
	 * @return Lower triangle of Matrix.
	 */
	 default Matrix tril(int k) {
<span class="nc" id="L537">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L538">		Matrix lower = Matrix.zeros(A.m, A.n);</span>
		
<span class="nc bnc" id="L540" title="All 2 branches missed.">		for(int i = 0; i &lt; lower.m; i++) {</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">			for(int j = 0; j&lt;=(i+k) &amp;&amp; j &lt; lower.n; j++) {</span>
<span class="nc" id="L542">				lower.entries[i][j] = A.entries[i][j];</span>
			}
		}
		
<span class="nc" id="L546">		return lower;</span>
	}
	
	
	/**
	 * Generates upper triangle of Matrix. That is, all values above the middle
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #triu(int) triu(int k)}&lt;/code&gt;
	 * 
	 * @return upper triangle of Matrix.
	 */
	 default Matrix triu() {
<span class="nc" id="L559">		return this.triu(0);</span>
	}
	
	
	/**
	 * Generates upper triangle of Matrix. That is, all values below the kth
	 * diagonal will be zeroed.
	 * 
	 * Also see &lt;code&gt;{@link #triu(int) triu()}&lt;/code&gt;
	 * 
	 * @param k - diagonal above which to zero. k=0 would be middle diagonal, k=-1 would be 
	 * 	the diagonal to the left of the middle diagonal, and k=1 would be the diagonal to the right
	 * 	of the middle diagonal.
	 * @return upper triangle of Matrix.
	 */
	 default Matrix triu(int k) {
<span class="nc" id="L575">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L576">		Matrix upper = Matrix.zeros(A.m, A.n);</span>
<span class="nc" id="L577">		int jstart = 0;</span>
		
		
<span class="nc bnc" id="L580" title="All 2 branches missed.">		for(int i = 0; i &lt; upper.m; i++) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">			if(i+k &lt;= 0) {jstart = 0;}</span>
<span class="nc" id="L582">			else {jstart = i+k;}</span>
			
<span class="nc bnc" id="L584" title="All 4 branches missed.">			for(int j = jstart; j-k&gt;=(i) &amp;&amp; j &lt; upper.n; j++) {</span>
<span class="nc" id="L585">				upper.entries[i][j] = A.entries[i][j];</span>
			}
		}
		
<span class="nc" id="L589">		return upper;</span>
	}
	
	
	/**
	 * Extracts diagonal elements from matrix.
	 * 
	 * @return Returns an equivalently sized matrix containing only the diagonal elements of this matrix.
	 */
	 default Matrix diag() {
<span class="nc" id="L599">		return this.triu(0).tril(0);</span>
	}


	/**
	 * Sets elements from list as diagonal elements of a zero matrix.
	 * @param entries Entries to use for diagonal of matrix.
	 * @return Returns a diagonal matrix containing the provided entries on the diagonal.
	 */
	 static Matrix toDiag(CNumber... entries) {
<span class="nc" id="L609">		Matrix A = new Matrix(entries.length);</span>
		
<span class="nc bnc" id="L611" title="All 2 branches missed.">		for(int i=0; i&lt;entries.length; i++) {</span>
<span class="nc" id="L612">			A.entries[i][i] = entries[i];</span>
		}
		
<span class="nc" id="L615">		return A;</span>
	}

	/**
	 * Sets elements from list as diagonal elements of a zero matrix.
	 * @param entries Entries to use for diagonal of matrix.
	 * @return Returns a diagonal matrix containing the provided entries on the diagonal.
	 */
	static Matrix toDiag(double... entries) {
<span class="nc" id="L624">		Matrix A = new Matrix(entries.length);</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">		for(int i=0; i&lt;entries.length; i++) {</span>
<span class="nc" id="L627">			A.entries[i][i] = new CNumber(entries[i]);</span>
		}

<span class="nc" id="L630">		return A;</span>
	}
	
	/**
	 * Extracts diagonal elements form matrix and stores in vector.
	 * 
	 * @return Column vector containing diagonal elements of this matrix.
	 */
	 default Vector diagAsVector() {
<span class="nc" id="L639">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L640">		Vector diag = new Vector(Math.min(A.m, A.n));</span>
		
<span class="nc bnc" id="L642" title="All 2 branches missed.">		for(int i=0; i&lt;diag.m; i++) {</span>
<span class="nc" id="L643">			diag.entries[i][0] = A.entries[i][i];</span>
		}
		
<span class="nc" id="L646">		return diag;</span>
	}
	
	
	/**
	 * Converts a matrix similar to this matrix that is in upper Hessenburg form. A matrix is in upper Hessenburg form if all entries below the first subdiagonal are
	 * zero. Two n-by-n matrices A and B are similar if there exists an invertible n-by-n matrix P, such that B=P&lt;sup&gt;-1&lt;/sup&gt;AP. Similar matrices share many 
	 * properties including the same eigenvalues.
	 * 
	 * @return A matrix similar to this matrix which is in upper Hessenburg form.
	 */
	 default Matrix hessu() {
<span class="nc" id="L658">		Matrix H = ((Matrix) this).copy();</span>
<span class="nc" id="L659">		Matrix x, v = new Matrix(H.m, H.m);</span>
<span class="nc" id="L660">		CNumber two = new CNumber(2), eps = new CNumber(Float.MIN_VALUE);</span>
		
<span class="nc bnc" id="L662" title="All 2 branches missed.">		if(!H.isSquare()) {</span>
<span class="nc" id="L663">			throw new IllegalArgumentException(&quot;Matrix must be square but got shape &quot; + H.shape);</span>
		}
		
		
<span class="nc bnc" id="L667" title="All 2 branches missed.">		for(int k=0; k&lt;H.m-2; k++) {	</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">			if(!H.getSlice(k+1, H.m, k, k+1).equals(new Matrix(H.m-(k+1), 1))) { // Then we need a Householder reflector. Otherwise, the column is already in the correct form so we don't need to apply a reflector.</span>
<span class="nc" id="L669">				x = H.getSlice(k+1, H.m, k, k+1);</span>
				
<span class="nc" id="L671">				v.setSlice(0, k, 	</span>
<span class="nc" id="L672">						Matrix.I(H.m-(k+1), 1).scalMult(</span>
<span class="nc" id="L673">						CNumber.multiply(</span>
<span class="nc" id="L674">							CNumber.addInv(CNumber.sign(CNumber.add(x.entries[0][0], eps))), </span>
<span class="nc" id="L675">							x.norm()</span>
<span class="nc" id="L676">						)).sub(x)</span>
				);
				
<span class="nc" id="L679">				v.setSlice(0, k, v.getSlice(0, H.m-(k+1), k, k+1).scalDiv(v.getSlice(0, H.m-(k+1), k, k+1).norm()));</span>
				
<span class="nc" id="L681">				H.setSlice(k+1, k, </span>
<span class="nc" id="L682">						H.getSlice(k+1, H.m, k, H.m).sub(v.getSlice(0, H.m-(k+1), k, k+1).mult(</span>
<span class="nc" id="L683">						v.getSlice(0, H.m-(k+1), k, k+1).H().mult(H.getSlice(k+1, H.m, k, H.m))).scalMult(two))</span>
				);
				
<span class="nc" id="L686">				H.setSlice(0, k+1, </span>
<span class="nc" id="L687">						H.getSlice(0, H.m, k+1, H.m).sub(H.getSlice(0, H.m, k+1, H.m).mult(</span>
<span class="nc" id="L688">						v.getSlice(0, H.m-(k+1), k, k+1)).mult(v.getSlice(0, H.m-(k+1), k, k+1).H()).scalMult(two))</span>
				);
			}
		}
		
<span class="nc" id="L693">		H.roundToZero(10);</span>
		
<span class="nc" id="L695">		return H;</span>
	}
	
	
	/**
	 * Converts a matrix similar to this matrix that is in upper Hessenburg form. A matrix is in upper Hessenburg form if all entries below the first subdiagonal are
	 * zero. Two n-by-n matrices A and B are similar if there exists an invertible n-by-n matrix P, such that B=P&lt;sup&gt;-1&lt;/sup&gt;AP. Similar matrices share many 
	 * properties including the same eigenvalues.
	 * 
	 * @return A matrix similar to this matrix which is in upper Hessenburg form.
	 */
	 default Matrix[] hessuV() {
<span class="nc" id="L707">		Matrix H = ((Matrix) this).copy();</span>
<span class="nc" id="L708">		Matrix x, v = new Matrix(H.m, H.m);</span>
<span class="nc" id="L709">		CNumber two = new CNumber(2), eps = new CNumber(Float.MIN_VALUE);</span>
<span class="nc" id="L710">		Matrix[] result = new Matrix[2];</span>
		
<span class="nc bnc" id="L712" title="All 2 branches missed.">		if(!H.isSquare()) {</span>
<span class="nc" id="L713">			throw new IllegalArgumentException(&quot;Matrix must be square but got shape &quot; + H.shape);</span>
		}
		
		
<span class="nc bnc" id="L717" title="All 2 branches missed.">		for(int k=0; k&lt;H.m-2; k++) {	</span>
<span class="nc" id="L718">			x = H.getSlice(k+1, H.m, k, k+1);</span>
			
<span class="nc" id="L720">			v.setSlice(0, k, 	</span>
<span class="nc" id="L721">					Matrix.I(H.m-(k+1), 1).scalMult(</span>
<span class="nc" id="L722">					CNumber.multiply(</span>
<span class="nc" id="L723">						CNumber.addInv(CNumber.sign(CNumber.add(x.entries[0][0], eps))), </span>
<span class="nc" id="L724">						x.norm()</span>
<span class="nc" id="L725">					)).sub(x)</span>
			);
			
<span class="nc" id="L728">			v.setSlice(0, k, v.getSlice(0, H.m-(k+1), k, k+1).scalDiv(v.getSlice(0, H.m-(k+1), k, k+1).norm()));</span>
			
<span class="nc" id="L730">			H.setSlice(k+1, k, </span>
<span class="nc" id="L731">					H.getSlice(k+1, H.m, k, H.m).sub(v.getSlice(0, H.m-(k+1), k, k+1).mult(</span>
<span class="nc" id="L732">					v.getSlice(0, H.m-(k+1), k, k+1).H().mult(H.getSlice(k+1, H.m, k, H.m))).scalMult(two))</span>
			);
			
<span class="nc" id="L735">			H.setSlice(0, k+1, </span>
<span class="nc" id="L736">					H.getSlice(0, H.m, k+1, H.m).sub(H.getSlice(0, H.m, k+1, H.m).mult(</span>
<span class="nc" id="L737">					v.getSlice(0, H.m-(k+1), k, k+1)).mult(v.getSlice(0, H.m-(k+1), k, k+1).H()).scalMult(two))</span>
			);
		}
		
<span class="nc" id="L741">		H.roundToZero(10);</span>
		
<span class="nc" id="L743">		result[0] = H;</span>
<span class="nc" id="L744">		result[1] = v;</span>
		
<span class="nc" id="L746">		return result;</span>
	}
	
	
	/**
	 * Swaps two rows in a matrix.
	 * 
	 * @param rowIndex1 - Index of first row to be swapped.
	 * @param rowIndex2 - Index of second row to be swapped.
	 * @return Matrix with specified rows swapped.
	 */
	 default Matrix swapRows(int rowIndex1, int rowIndex2) {
<span class="nc" id="L758">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L759">		Matrix result = A.copy();</span>
		
<span class="nc" id="L761">		CNumber[] row1 = A.entries[rowIndex1];</span>
<span class="nc" id="L762">		CNumber[] row2 = A.entries[rowIndex2];</span>
		
<span class="nc" id="L764">		result.entries[rowIndex1] = row2;</span>
<span class="nc" id="L765">		result.entries[rowIndex2] = row1;</span>
		
<span class="nc" id="L767">		return result;</span>
	}
	
	
	/**
	 * Swaps two columns in a matrix.
	 * 
	 * @param colIndex1 - Index of first column to be swapped.
	 * @param colIndex2 - Index of second column to be swapped.
	 * @return Matrix with specified columns swapped.
	 */
	 default Matrix swapCols(int colIndex1, int colIndex2) {
<span class="nc" id="L779">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L780">		Matrix result = A.copy();</span>
		
<span class="nc" id="L782">		CNumber[] col1 = A.getCol(colIndex1);</span>
<span class="nc" id="L783">		CNumber[] col2 = A.getCol(colIndex2);</span>
		
<span class="nc bnc" id="L785" title="All 2 branches missed.">		for(int i = 0; i&lt;A.m; i++) {</span>
<span class="nc" id="L786">			result.entries[i][colIndex1] = col2[i];</span>
<span class="nc" id="L787">			result.entries[i][colIndex2] = col1[i];</span>
		}
		
<span class="nc" id="L790">		return result;</span>
	}
	
	
	/**
	 * Multiplies a specified row by a constant value.
	 * 
	 * @param factor - number to multiply row by.
	 * @return Matrix with specified row multiplied by the factor.
	 */
	 default Matrix multRow(int rowIndex, CNumber factor) {
<span class="nc" id="L801">		Matrix A = (Matrix) this;</span>
<span class="nc" id="L802">		Matrix result = new Matrix(A.m, A.n);</span>
		
<span class="nc bnc" id="L804" title="All 2 branches missed.">		for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc" id="L805">			result.entries[rowIndex][j] = CNumber.multiply(A.entries[rowIndex][j], factor); </span>
		}
		
<span class="nc" id="L808">		return result;</span>
	}

	
	/**
	 * Multiplies a specified row by a constant value.
	 * 
	 * @param factor - number to multiply row by.
	 * @return Matrix with specified row multiplied by the factor
	 */
	 default Matrix multRow(int rowIndex, double factor) {
<span class="nc" id="L819">		return multRow(rowIndex, new CNumber(factor));</span>
	}
	
	
	/**
	 * Divides a specified row by a constant value.
	 * 
	 * @param divisor - number to divide row by.
	 * @return Matrix with specified row divided by the divisor.
	 */
	 default Matrix divRow(int rowIndex, CNumber divisor) {
<span class="nc" id="L830">		return multRow(rowIndex, CNumber.inv(divisor));</span>
	}
	
	
	/**
	 * Divides a specified row by a constant value.
	 * 
	 * @param divisor - number to divide row by.
	 * @return Matrix with specified row divided by the divisor.
	 */
	 default Matrix divRow(int rowIndex, double divisor) {
<span class="nc" id="L841">		return multRow(rowIndex, 1 / divisor);</span>
	}
	
	
	/**
	 * If possible, converts matrix to a Vector object.&lt;br&gt;&lt;br&gt;
	 * A matrix will be converted to a row vector if it contains only a single row. &lt;br&gt;
	 * A matrix will be converted to a column vector if it contains only a single column. &lt;br&gt;
	 * If a matrix contains only one row and one column or is empty, then it will be converted to a column vector by default.&lt;br&gt;
	 * 
	 * @return Vector equivalent of matrix.
	 */
	 default Vector toVector() {
<span class="nc" id="L854">		Matrix A = (Matrix) this;</span>
		Vector result;
		
<span class="nc bnc" id="L857" title="All 4 branches missed.">		if(!A.isVector() &amp;&amp; !A.isEmpty()) {</span>
<span class="nc" id="L858">			throw new IllegalArgumentException(&quot;Can not convert matrix of shape &quot; + A.shape + &quot; to a vector.&quot;);</span>
		} else {
<span class="nc" id="L860">			int vectorType = A.vectorType();</span>
			
			
<span class="nc bnc" id="L863" title="All 2 branches missed.">			if(A.isEmpty()) {</span>
<span class="nc" id="L864">				result = new Vector();</span>
			}
			else { // 1-by-1 matrix or empty matrix will default to a column vector.
<span class="nc bnc" id="L867" title="All 2 branches missed.">				if(vectorType == 3) {</span>
<span class="nc" id="L868">					vectorType = Vector.COLUMN_VECTOR;</span>
				}
				
<span class="nc" id="L871">				result = new Vector(LinAlgArrayUtils.flatten(A.entries), vectorType);</span>
			}
		}
		
<span class="nc" id="L875">		return result;</span>
	}
	
	
	/**
	 * Rounds all entries of a matrix. If entry is complex, 
	 * both the real and imaginary part will be rounded.
	 *
	 * @param decimals - Number of decimals to round number to.
	 * @return Returns copy of Matrix &lt;code&gt;A&lt;/code&gt; with entries rounded to 
	 * 		Specified number of decimal places.  
	 */
	 default Matrix round(int decimals) {
<span class="nc" id="L888">		Matrix rounded = new Matrix((Matrix) this);</span>
		
<span class="nc bnc" id="L890" title="All 2 branches missed.">		for(int i=0; i&lt;rounded.m; i++) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">			for(int j=0; j&lt;rounded.n; j++) {</span>
<span class="nc" id="L892">				rounded.entries[i][j] = CNumber.round(rounded.entries[i][j], decimals);</span>
			}
		}
		
<span class="nc" id="L896">		return rounded;</span>
	}
	
	
	/**
	 * Rounds values in this matrix within a specified number of decimals of zero to zero.
	 * 
	 * @param decimals - Number of decimals 
	 */
	 default void roundToZero(int decimals) {
<span class="nc" id="L906">		double tolerance = 0.5*Math.pow(10, -decimals);</span>
<span class="nc" id="L907">		Matrix A = (Matrix) this;</span>
		
<span class="nc bnc" id="L909" title="All 2 branches missed.">		for(int i=0; i&lt;A.m; i++) {</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">			for(int j=0; j&lt;A.n; j++) {</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">				if(Math.abs(A.entries[i][j].mag()) &lt; tolerance) {</span>
<span class="nc" id="L912">					A.entries[i][j] = CNumber.ZERO;</span>
				}
			}
		}
<span class="nc" id="L916">	}</span>


	 public static void main(String[] args) {

<span class="nc" id="L921">		double[] val = {1, 2, 3, 4};</span>
<span class="nc" id="L922">		Vector v = new Vector(val, 0);</span>

<span class="nc" id="L924">		Matrix.println(v.extend(4));</span>
<span class="nc" id="L925">	}</span>
}









</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>