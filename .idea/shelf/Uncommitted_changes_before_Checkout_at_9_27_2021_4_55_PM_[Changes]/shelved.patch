Index: src/main/java/linalg/MatrixOperations.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package linalg;\r\n\r\nimport linalg.complex_number.CNumber;\r\n\r\n/**\r\n * This interface provides several methods useful for matrix operations.\r\n * \r\n * @author Jacob Watters\r\n */\r\ninterface MatrixOperations {\r\n\t\r\n\t/**\r\n\t * Performs matrix addition on two matrices of the same dimensions.\r\n\t * \r\n\t * @param B - matrix to add to the instance matrix\r\n\t * @return result of matrix addition\r\n\t */\r\n\t default Matrix add(Matrix B) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix C = new Matrix(A.m, A.n);\r\n\t\tMatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tC.entries[i][j].re = A.entries[i][j].re + B.entries[i][j].re;\r\n\t\t\t\tC.entries[i][j].im = A.entries[i][j].im + B.entries[i][j].im;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn C;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Adds the value of a to all entries of matrix.\r\n\t * @param a Value to add to matrix.\r\n\t * @return A new matrix with the value of a added to this matrix.\r\n\t */\r\n\tdefault Matrix add(double a) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix C = new Matrix(A.m, A.n);\r\n\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tC.entries[i][j].re = A.entries[i][j].re + a;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn C;\r\n\t}\r\n\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs matrix subtraction on two matrices of the same dimensions.\r\n\t * \r\n\t * @param B - matrix to subtract to the instance matrix\r\n\t * @return result of matrix subtraction\r\n\t */\r\n\t default Matrix sub(Matrix B) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix C = new Matrix(A.m, A.n);\r\n\t\tMatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tC.entries[i][j].re = A.entries[i][j].re - B.entries[i][j].re;\r\n\t\t\t\tC.entries[i][j].im = A.entries[i][j].im - B.entries[i][j].im;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn C;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs matrix multiplication on two matrices. The instance matrix\r\n\t * must have the same number of columns as the rows of B.\r\n\t * \r\n\t * If the instance matrix is a kxm matrix and B is a \r\n\t * m x n matrix then the result will be a k x n matrix.\r\n\t * \r\n\t * @param B - matrix to multiply to the instance matrix\r\n\t * @return result of matrix multiplication\r\n\t */\r\n\t default Matrix mult(Matrix B) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\t\r\n\t\tif(!MatrixComparisons.matMultCheck(A, B)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Number of columns in first matrix must match \\n\"\r\n\t\t\t\t\t+ \"number of rows in seccond matrix but got \" + A.shape() + \" and \" + B.shape() + \".\");\r\n\t\t}\r\n\t\t\r\n\t\tMatrix product = new Matrix(A.m, B.n);\r\n\t\t\r\n\t\tfor(int i = 0; i < product.m; i++) {\r\n\t\t\tfor(int k = 0; k < A.n; k++) {\r\n\t\t\t\tfor(int j = 0; j < product.n; j++) {\r\n\t\t\t\t\tproduct.entries[i][j].re += (A.entries[i][k].re * B.entries[k][j].re - A.entries[i][k].im * B.entries[k][j].im);\r\n\t\t\t\t\tproduct.entries[i][j].im += (A.entries[i][k].re * B.entries[k][j].im + A.entries[i][k].im * B.entries[k][j].re);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn product;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs element-wise multiplication of two matrices.\r\n\t * \r\n\t * @throws IllegalArgumentException If matrices do not have the same dimension.\r\n\t * @param B - matrix to multiply element-wise to this matrix.\r\n\t * @return result of element-wise matrix multiplication.\r\n\t */\r\n\t default Matrix elemMult(Matrix B) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix C = new Matrix(A.m, A.n);\r\n\t\tMatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tC.entries[i][j].re = A.entries[i][j].re * B.entries[i][j].re - A.entries[i][j].im * B.entries[i][j].im;\r\n\t\t\t\tC.entries[i][j].im = A.entries[i][j].re * B.entries[i][j].im + A.entries[i][j].im * B.entries[i][j].re;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn C;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs scalar multiplication of a matrix.\r\n\t * \r\n\t * @param factor - value to multiply this matrix by.\r\n\t * @return The scalar multiplication of the matrix and the factor.\r\n\t */\r\n\t default Matrix scalMult(double factor) {\r\n\t\treturn this.scalMult(new CNumber(factor));\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs scalar multiplication of a matrix.\r\n\t * \r\n\t * @param factor - value to multiply matrix by.\r\n\t * @return The scalar multiplication of the matrix and the factor.\r\n\t */\r\n\t default Matrix scalMult(CNumber factor) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix result = new Matrix(A.m, A.n);\r\n\t\t\r\n\t\tfor(int i = 0; i < A.m; i++) {\r\n\t\t\tfor(int j = 0; j <  A.n; j++) {\r\n\t\t\t\tresult.entries[i][j] = CNumber.multiply(A.entries[i][j], factor);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs element-wise division on two matrices of the same dimensions.\r\n\t * \r\n\t * @param B - matrix to divide element-wise the instance matrix with.\r\n\t * @return result of element-wise matrix multiplication.\r\n\t */\r\n\t default Matrix elemDiv(Matrix B) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix C = new Matrix(A.m, A.n);\r\n\t\tMatrixChecks.dimensionCheck(A, B, MatrixChecks.SAME_DIM);\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tC.entries[i][j].re = \t(A.entries[i][j].re * B.entries[i][j].re + A.entries[i][j].im * B.entries[i][j].im) / \r\n\t\t\t\t\t\t\t\t\t\t(B.entries[i][j].re * B.entries[i][j].re + B.entries[i][j].im * B.entries[i][j].im);\r\n\t\t\t\t\r\n\t\t\t\tC.entries[i][j].im = \t(A.entries[i][j].im * B.entries[i][j].re - A.entries[i][j].re * B.entries[i][j].im) / \r\n\t\t\t\t\t\t\t\t\t\t(B.entries[i][j].re * B.entries[i][j].re + B.entries[i][j].im * B.entries[i][j].im);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn C;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs scalar division of this matrix.\r\n\t * \r\n\t * @param divisor - value to divide matrix by.\r\n\t * @return The scalar division of the matrix and the divisor.\r\n\t */\r\n\t default Matrix scalDiv(double divisor) {\r\n\t\tdouble factor = 1/divisor;\r\n\t\treturn this.scalMult(new CNumber(factor));\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Performs scalar division of this matrix.\r\n\t * \r\n\t * @param divisor - value to divide matrix by.\r\n\t * @return The scalar division of the matrix and the divisor.\r\n\t */\r\n\t default Matrix scalDiv(CNumber divisor) {\r\n\t\tCNumber factor = CNumber.divide(CNumber.ONE, divisor);\r\n\t\treturn this.scalMult(factor);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the Frobenius inner product of two matrices A and B, {@code <A, B>}<sub>F</sub>.\r\n\t * \r\n\t * @param B - Second matrix for the Frobenius inner product.\r\n \t * @return the Frobenius inner product.\r\n\t */\r\n\t default CNumber fip(Matrix B) {\r\n\t\treturn this.mult(B).tr();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the matrix direct sum. That is, a block diagonal matrix containing all matrices from a set of matrices.\r\n\t * \r\n\t * @param matrixList - List of matrices from which to compute the matrix direct sum.\r\n\t * @return The result of direct summing the matrices in matrixList to this matrix.\r\n\t */\r\n\t default Matrix directSum(Matrix... matrixList) { // TODO: Because this is not static, include \"this\" in the direct sum.\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tint new_m = A.m, new_n = A.n,\r\n\t\t\tcurrent_m = 0, current_n = 0;\r\n\t\t\r\n\t\tfor(int i=0; i<matrixList.length; i++) {\t\t\t\r\n\t\t\tnew_m += matrixList[i].m;\r\n\t\t\tnew_n += matrixList[i].n;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tMatrix directSum = new Matrix(new_m, new_n);\r\n\t\t\r\n\t\tfor(int i=-1; i<matrixList.length; i++) {\r\n\t\t\tif(i==-1) {\r\n\t\t\t\tdirectSum.setSlice(current_m, current_n, A);\r\n\t\t\t\tcurrent_m += A.m;\r\n\t\t\t\tcurrent_n += A.n;\r\n\t\t\t} else {\r\n\t\t\t\tdirectSum.setSlice(current_m, current_n, matrixList[i]);\r\n\t\t\t\tcurrent_m += matrixList[i].m;\r\n\t\t\t\tcurrent_n += matrixList[i].n;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn directSum;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes element wise square root of the matrix. All square roots are the positive root or, in\r\n\t * the case of complex entries, the root with positive real part.\r\n\t * \r\n\t * @return The element-wise square root of this matrix.\r\n\t */\r\n\t default Matrix sqrt() {\r\n\t\tMatrix A = ((Matrix) this).copy();\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tA.entries[i][j] = CNumber.sqrt(A.entries[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn A;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes absolute value, element-wise, of a matrix.\r\n\t * If any of the matrix cells are complex, this will result\r\n\t * in the magnitude of that value.\r\n\t * \r\n\t * @return - element-wise absolute value of matrix.\r\n\t */\r\n\t default Matrix abs() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix abs = new Matrix(A.m, A.n);\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tabs.entries[i][j] = CNumber.abs(A.entries[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn abs;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Transposes Matrix. Same as <code> Matrix.T() </code>\r\n\t * \r\n\t * @return transpose of matrix\r\n\t */\r\n\t default Matrix transpose() {\r\n\t\treturn this.T();\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Transposes Matrix. Same as <code> Matrix.transpose() </code>\r\n\t * \r\n\t * @return transpose of matrix\r\n\t */\r\n\t default Matrix T() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix At = new Matrix(A.n, A.m);\r\n\t\t\r\n\t    final int BLOCK_SIZE = 16;\r\n\t    \r\n\t    // Compute transpose using blocked algorithm\r\n\t    for(int i = 0; i < A.m; i += BLOCK_SIZE) {\r\n\t        for (int j = 0; j < A.n; j += BLOCK_SIZE) {\r\n\t            // transpose the block beginning at [i,j]\r\n\t            for (int k = i; k < i + BLOCK_SIZE && k < A.m; ++k) {\r\n\t                for (int l = j; l < j + BLOCK_SIZE && l < A.n; ++l) {\r\n\t                    At.entries[l][k] = A.entries[k][l];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    \r\n\t    return At;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Conjugates a matrix element-wise.\r\n\t * \r\n\t * @return Conjugate of matrix\r\n\t */\r\n\t default Matrix conjugate() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix Ac = new Matrix(A.m, A.n);\r\n\t\t\r\n\t\tfor(int i = 0; i < Ac.m; i++) {\r\n\t\t\tfor(int j = 0; j < Ac.n; j++) {\r\n\t\t\t\tAc.entries[i][j] = CNumber.conjugate(A.entries[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn Ac;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the conjugate transpose of this matrix. \r\n\t * <br><br>\r\n\t * This method is the same as {@link #hermAdjoint() hermAdjoint()} and {@link #H() H()}. \r\n\t * \r\n\t * @return The conjugate transpose of this matrix.\r\n\t */\r\n\t default Matrix conjT() {\r\n\t\treturn this.conjugate().T();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the Hermation adjoint of a matrix. This is the transpose of the conjugate matrix.\r\n\t * <br><br>\r\n\t * This method is the same as {@link #conjT() conjT()}  and {@link #H() H()}. \r\n\t * \r\n\t * @return adjoint of matrix.\r\n\t */\r\n\t default Matrix hermAdjoint() {\r\n\t\treturn this.conjugate().T();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the Hermation adjoint of a matrix. This is the transpose of the conjugate matrix.\r\n\t * <br><br>\r\n\t * This method is the same as {@link #conjT() conjT()} and {@link #hermAdjoint() hermAdjpint()}.\r\n\t * \r\n\t * @return adjoint of matrix.\r\n\t */\r\n\t default Matrix H() {\r\n\t\treturn this.conjugate().T();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes determinant of matrix using reccurisive definition. This method exists\r\n\t * for computing the determinant of non-real matrices.\r\n\t * \r\n\t * @param A - Matrix to compute determinant of\r\n\t * @return determinant of matrix A\r\n\t */\r\n\tstatic CNumber detRec(Matrix A) {\r\n\t\tCNumber value = CNumber.ZERO;\r\n\t\t\r\n\t\tif(A.m == 1 && A.n == 1) { // Then we simply have a 1x1 matrix.\r\n\t\t\treturn A.entries[0][0];\r\n\t\t}\r\n\t\telse if(A.m == 2 && A.n == 2) { // Then we have a 2x2 matrix, which is the base case\r\n\t\t\tCNumber a = A.entries[0][0];\r\n\t\t\tCNumber b = A.entries[0][1];\r\n\t\t\tCNumber c = A.entries[1][0];\r\n\t\t\tCNumber d = A.entries[1][1];\r\n\t\t\t\r\n\t\t\tvalue = CNumber.subtract(CNumber.multiply(a, d), CNumber.multiply(b, c));\r\n\t\t} \r\n\t\telse {\r\n\t\t\tfor(int j = 0; j < A.n; j++) {\r\n\t\t\t\tMatrix newA = A.removeRow(0).removeCol(j);\r\n\t\t\t\t\r\n\t\t\t\tCNumber num = new CNumber(Math.pow(-1, j));\r\n\t\t\t\tnum = CNumber.multiply(num, A.entries[0][j]);\r\n\t\t\t\t\r\n\t\t\t\tvalue = CNumber.add(value, CNumber.multiply(detRec(newA), num));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn value;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes determinant of real matrix using QR decomposition.\r\n\t * \r\n\t * @param A - Matrix to compute determinant of.\r\n\t * @return determinant of matrix A\r\n\t */\r\n\tstatic CNumber detQR(Matrix A) {\r\n\t\tCNumber detQ, detR = CNumber.ONE;\r\n\t\tMatrix[] QRh = Decompose.QR(A, true);\r\n\t\t\r\n\t\tdetQ = new CNumber(Math.pow(-1, QRh[2].entries[0][0].getReal()));\r\n\t\t\r\n\t\tfor(int i = 0; i<QRh[1].n; i++) {\r\n\t\t\tdetR = CNumber.multiply(detR, QRh[1].entries[i][i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn CNumber.multiply(detR, detQ);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes determinant of matrix. If the matrix has\r\n\t * any complex entries, this may be a complex value.\r\n\t * Note: Currently this method only works for real matirces.\r\n\t * \r\n\t * @return determinant of matrix.\r\n\t */\r\n\t default CNumber det() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\t\r\n\t\tif(!A.isSquare()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Matrix must be square but got shape \" + A.shape);\r\n\t\t}\r\n\t\t\r\n\t\tif(A.m == 2 && A.n == 2) { // Then we have a 2x2 matrix, which we can directly compute\r\n\t\t\tCNumber a = A.entries[0][0];\r\n\t\t\tCNumber b = A.entries[0][1];\r\n\t\t\tCNumber c = A.entries[1][0];\r\n\t\t\tCNumber d = A.entries[1][1];\r\n\t\t\t\r\n\t\t\treturn CNumber.subtract(CNumber.multiply(a, d), CNumber.multiply(b, c));\r\n\t\t}\r\n\t\t\r\n\t\treturn detQR(A);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Stacks matrices along rows. Both matrices must have the same number of columns\r\n\t * Also see {@link #stack(Matrix, int) stack(Matrix B, int axis)}\r\n\t * \r\n\t * @param B\r\n\t * @return\r\n\t */\r\n\t default Matrix stack(Matrix B) {\r\n\t\treturn this.stack(B, 0);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Stacks matrices along specified axis. Axis 0 will stack matrices along the rows. Axis 1 will\r\n\t * stack matrices along columns.\r\n\t * \r\n\t * Note: To stack matrices along axis 0 they must have the same number of columns.\r\n\t * To stack matrices along axis 1 they must have the same number of rows.\r\n\t * \r\n\t * @param B - Matrix to stack\r\n\t * @param axis - Axis along which to stack matrices.\r\n\t * @return Returns A and B stacked along specified axis.\r\n\t */\r\n\t default Matrix stack(Matrix B, int axis) {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix result = null;\r\n\t\t\r\n\t\tif(axis == 0) { // Stack on rows\r\n\t\t\tif(A.entries[0].length != B.entries[0].length) { // Ensure matricies have same number or columns\r\n\t\t\t\tthrow new IllegalArgumentException(\"Must have same number of columns but \"\r\n\t\t\t\t\t\t+ \"got \" + A.entries[0].length + \" and \" + B.entries[0].length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresult = new Matrix(A.entries.length+B.entries.length, A.entries[0].length);\r\n\t\t\t\r\n\t\t\tfor(int i = 0; i < result.entries.length; i++) {\r\n\t\t\t\tfor(int j = 0; j < result.entries[0].length; j++) {\r\n\t\t\t\t\tif(i < A.entries.length) { // Then copy from A.entries\r\n\t\t\t\t\t\tresult.entries[i][j] = A.entries[i][j];\r\n\t\t\t\t\t} else { // the copy from B.entries\r\n\t\t\t\t\t\tresult.entries[i][j] = B.entries[i-A.entries.length][j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} \r\n\t\telse if(axis == 1) { // Stack on cols\r\n\t\t\tif(A.entries.length != B.entries.length) { // Ensure matricies have same number or rows\r\n\t\t\t\tthrow new IllegalArgumentException(\"Must have same number of rows but \"\r\n\t\t\t\t\t\t+ \"got \" + A.entries.length + \" and \" + B.entries.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresult = new Matrix(A.entries.length, A.entries[0].length + B.entries[0].length);\r\n\t\t\t\r\n\t\t\tfor(int i = 0; i < result.entries.length; i++) {\r\n\t\t\t\tfor(int j = 0; j < result.entries[0].length; j++) {\r\n\t\t\t\t\tif(j < A.entries[0].length) { // Then copy from A.entries\r\n\t\t\t\t\t\tresult.entries[i][j] = A.entries[i][j];\r\n\t\t\t\t\t} else { // the copy from B.entries\r\n\t\t\t\t\t\tresult.entries[i][j] = B.entries[i][j-A.entries[0].length];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new IllegalArgumentException(\"axis must be 0 or 1 but got \" + axis);\r\n\t\t}\t\t\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Augments two matrices. This is the same as {@link #stack(Matrix, int) stack(B, 1)}\r\n\t * \r\n\t * @param B - Matrix to augment to this matrix.\r\n\t * @return The matrix B augmented to this matrix.\r\n\t */\r\n\t default Matrix augment(Matrix B) {\r\n\t\treturn this.stack(B, 1);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes row-echelon form of matrix. This will be an upper-triangular matrix.<br>\r\n\t * \r\n\t * <pre>\r\n\t * A matrix is in row-echelon form if:\r\n\t *  - The first non-zero element in each row, called the leading entry (also called the pivot), is 1.\r\n\t *  - The pivot of a nonzero row is always strictly to \r\n\t *    the right of the leading coefficient of the row above it.\r\n\t *  - Rows with all zero elements, if any, are below rows having a non-zero element.\r\n\t * </pre>\r\n\t * \r\n\t * A matrix can be transformed into a row equivalent matrix in row-echelon form using row operations.\r\n\t * This is done using Gaussian (Gauss-Jordan) elimination. <br><br>\r\n\t * \r\n\t * Also see <code>{@link #rref() rref()}</code> for reduced row-echelon form.\r\n\t * \r\n\t * @return Row-echelon form of matrix\r\n\t */\r\n\t default Matrix ref() {\r\n\t\tMatrix A = ((Matrix) this).copy();\r\n\t\tCNumber m, scale;\r\n\t\t\r\n\t\tint pivotRow = 0,\r\n\t\t\tpivotCol = 0;\r\n\t\t\r\n\t\twhile(pivotRow<A.m && pivotCol<A.n) {\r\n\t\t\tif(!A.entries[pivotRow][pivotCol].equals(CNumber.ZERO)) { // Then we can make the pivot one.\r\n\t\t\t\t scale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);\r\n\t\t\t\t \r\n\t\t\t\t for(int k=pivotCol; k<A.n; k++) { // scale the whole row\r\n\t\t\t\t\t A.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale); \r\n\t\t\t\t }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int i=pivotRow+1; i<A.m; i++) {\r\n\t\t\t\tm = A.entries[i][pivotCol];\r\n\r\n\t\t\t\tfor(int k=pivotCol; k<A.n; k++) {\r\n\t\t\t\t\tA.entries[i][k] = CNumber.subtract(A.entries[i][k], \r\n\t\t\t\t\t\t\tCNumber.multiply(A.entries[pivotRow][k], m));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t/*\r\n\t\t\t\t * This insures the entries to the left of the pivot are zero. \r\n\t\t\t\t * They may be a very small (in absolute value) non-zero value\r\n\t\t\t\t * resulting from errors in floating point arithmetic.\r\n\t\t\t\t */\r\n\t\t\t\tA.entries[i][pivotCol] = CNumber.ZERO;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpivotRow++;\r\n\t\t\tpivotCol++;\r\n\t\t}\r\n\t\t\r\n\t\treturn A;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes reduced row-echelon form of matrix.<br>\r\n\t * \r\n\t * <pre>\r\n\t * A matrix is in reduced row-echelon form if:<br>\r\n\t *  - It is in row-echelon form. This is,\r\n\t *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.\r\n\t *      ~ The pivot of a nonzero row is always strictly to \r\n\t *        the right of the leading coefficient of the row above it.\r\n\t *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.<br>\r\n\t *  - The pivot in each row is the only non-zero entry in its column.\r\n\t * </pre>\r\n\t * \r\n\t * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.\r\n\t * This is done using Gaussian (Gauss-Jordan) elimination. <br><br>\r\n\t * \r\n\t * @param partialPivoting - Falg for use of partial pivoting.\r\n\t * <pre>\r\n\t *  - If true then the rref will be computed using partial pivoting.\r\n\t * \t    ~ This is equivalent to the method {@link #rref() rref()}.\r\n\t *  - If false then the rref will be computed WITHOUT using partial pivoting.\r\n\t * </pre>\r\n\t * @return\r\n\t */\r\n\t default Matrix rref(boolean partialPivoting) {\r\n\t\tif(partialPivoting) return rref();\r\n\t\telse return rrefNoPivot();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes reduced row-echelon form of matrix. This is done using partial pivoting.<br>\r\n\t * \r\n\t * <pre>\r\n\t * A matrix is in reduced row-echelon form if:<br>\r\n\t *  - It is in row-echelon form. This is,\r\n\t *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.\r\n\t *      ~ The pivot of a nonzero row is always strictly to \r\n\t *        the right of the leading coefficient of the row above it.\r\n\t *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.<br>\r\n\t *  - The pivot in each row is the only non-zero entry in its column.\r\n\t * </pre>\r\n\t * \r\n\t * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.\r\n\t * This is done using Gaussian (Gauss-Jordan) elimination. <br><br>\r\n\t * \r\n\t * Also see <code>{@link #ref() ref()}</code> for row-echelon form.\r\n\t * \r\n\t * @return Row-echelon form of matrix.\r\n\t */\r\n\t default Matrix rref() {\r\n\t\tMatrix A = ((Matrix) this).copy();\r\n\t\tCNumber mult, scale, currentMax;\r\n\t\tint maxIndex;\r\n\t\t\r\n\t\tint pivotRow = 0,\r\n\t\t\tpivotCol = 0;\r\n\t\t\r\n\t\twhile(pivotRow<A.m && pivotCol<A.n) {\r\n\t\t\tmaxIndex = pivotRow;\r\n\t\t\tcurrentMax = A.entries[pivotRow][pivotCol];\r\n\t\t\t\r\n\t\t\tfor(int i=pivotRow; i<A.m; i++) { // Find the maximum entry in the pivot column (at or below the pivot ).\r\n\t\t\t\tif(A.entries[i][pivotCol].nearZero(1.0E-12)) { \r\n\t\t\t\t\t\r\n\t\t\t\t\t/* \r\n\t\t\t\t\t * If a number is very close to zero, assume it is supposed to be zero.\r\n\t\t\t\t\t * This protects against trying to manipulate a column which\r\n\t\t\t\t\t * is already in the correct form.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tA.entries[i][pivotCol] = CNumber.ZERO;\r\n\t\t\t\t}\r\n\t\t\t\telse if(A.entries[i][pivotCol].compareTo(currentMax) > 0) {\r\n\t\t\t\t\tmaxIndex = i;\r\n\t\t\t\t\tcurrentMax = A.entries[i][pivotCol];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!A.entries[maxIndex][pivotCol].equals(CNumber.ZERO)) { // Check that the maximum absolute value is not zero.\r\n\t\t\t\tif(pivotRow != maxIndex) {\r\n\t\t\t\t\tA = A.swapRows(pivotRow, maxIndex); // Make the row with the largest value in the pivot column the pivot for this row.\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tscale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);\r\n\t\t\t\t \r\n\t\t\t\tfor(int k=pivotCol; k<A.n; k++) { // scale the whole row so that the pivot is 1\r\n\t\t\t\t\tA.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale); \r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\t\t\tmult = A.entries[i][pivotCol];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(pivotRow != i) {\r\n\t\t\t\t\t\tA.entries[i][pivotCol] = CNumber.ZERO;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor(int k=pivotCol+1; k<A.n; k++) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tCNumber value = CNumber.subtract(A.entries[i][k], \r\n\t\t\t\t\t\t\t\t\tCNumber.multiply(A.entries[pivotRow][k], mult));\r\n\t\t\t\t\t\t\tA.entries[i][k] = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tpivotRow++;\r\n\t\t\t\tpivotCol++;\r\n\t\t\t}\r\n\t\t\telse { // Then we do not have a pivot for this column (i.e. the column is all zeros).\r\n\t\t\t\tpivotCol++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn A;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes reduced row-echelon form of matrix. \r\n\t * This is done WITHOUT using partial pivoting.<br>\r\n\t * \r\n\t * <pre>\r\n\t * A matrix is in reduced row-echelon form if:<br>\r\n\t *  - It is in row-echelon form. This is,\r\n\t *      ~ The first non-zero element in each row, called the leading entry (also called the pivot), is 1.\r\n\t *      ~ The pivot of a nonzero row is always strictly to \r\n\t *        the right of the leading coefficient of the row above it.\r\n\t *      ~ Rows with all zero elements, if any, are below rows having a non-zero element.<br>\r\n\t *  - The pivot in each row is the only non-zero entry in its column.\r\n\t * </pre>\r\n\t * \r\n\t * A matrix can be transformed into a row eqivalent matrix in reduced row-echelon form using row operations.\r\n\t * This is done using Gaussian (Gauss-Jordan) elimination. <br><br>\r\n\t * \r\n\t * Also see <code>{@link #ref() ref()}</code> for row-echelon form.\r\n\t * \r\n\t * @return Row-echelon form of matrix.\r\n\t */\r\n\tdefault Matrix rrefNoPivot() {\r\n\t\tMatrix A = ((Matrix) this).copy();\r\n\t\tCNumber m, scale;\r\n\t\t\r\n\t\tint pivotRow = 0,\r\n\t\t\tpivotCol = 0;\r\n\t\t\r\n\t\twhile(pivotRow<A.m && pivotCol<A.n) {\r\n\t\t\tif(!A.entries[pivotRow][pivotCol].equals(CNumber.ZERO)) { \r\n\t\t\t\tscale = CNumber.divide(CNumber.ONE, A.entries[pivotRow][pivotCol]);\r\n\t\t\t\t \r\n\t\t\t\tfor(int k=pivotCol; k<A.n; k++) { // scale the whole row\r\n\t\t\t\t\tA.entries[pivotRow][k] = CNumber.multiply(A.entries[pivotRow][k], scale); \r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\t\tm = A.entries[i][pivotCol];\r\n\t\t\t\t\r\n\t\t\t\tif(pivotRow != i) {\r\n\t\t\t\t\tfor(int k=pivotCol; k<A.n; k++) {\r\n\t\t\t\t\t\tA.entries[i][k] = CNumber.subtract(A.entries[i][k], \r\n\t\t\t\t\t\t\t\tCNumber.multiply(A.entries[pivotRow][k], m));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpivotRow++;\r\n\t\t\tpivotCol++;\r\n\t\t}\r\n\t\t\r\n\t\treturn A;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes reduced extended row-echelon form of matrix. That is, a Matrix with\r\n\t * the same number of rows is {@link #augment(Matrix) augmented} with this matrix and\r\n\t * then this augmented matrix is put into {@link #rref() reduced row-echelon form}.\r\n\t * \r\n\t * @return Returns extended row-echelon form of this matrix.\r\n\t */\r\n\t default Matrix erref() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix I = Matrix.I(A.m);\r\n\t\tMatrix Aug = A.augment(I);\r\n\t\t\r\n\t\treturn Aug.rref();\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Computes the trace of square matrix. That is, the sum \r\n\t * of the entries along the principle diagonal.\r\n\t * <br><br>\r\n\t * This method is the same as {@link #tr() tr()}.\r\n\t * \r\n\t * @return trace of this matrix.\r\n\t */\r\n\t default CNumber trace() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\t\r\n\t\tif(!A.isSquare()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Expecting matrix to be square but got \" + A.shape);\r\n\t\t}\r\n\t\t\r\n\t\tCNumber result = A.entries[0][0];\r\n\t\t\r\n\t\tfor(int i = 1; i < A.n; i++) {\r\n\t\t\tresult = CNumber.add(result, A.entries[i][i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t} \r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the trace of a square matrix. That is, the sum \r\n\t * of the entries along the principle diagonal.\r\n\t * <br><br>\r\n\t * This method is the same as {@link #trace() trace()}.\r\n\t * \r\n\t * @return trace of this matrix.\r\n\t */\r\n\t default CNumber tr() {\r\n\t\treturn this.trace();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * The rank of a matrix A is the dimension of the vector space generated (or spanned) by its columns.\r\n\t * This is always an integer.\r\n\t * This corresponds to the maximal number of linearly independent columns of A. \r\n\t * This, in turn, is identical to the dimension of the vector space spanned by its rows\r\n\t * \r\n\t * @return Returns the rank of this matrix.\r\n\t */\r\n\t// TODO: Should be switched to rank revealing QR decomposition as it is more numerically stable.\r\n\t default int rank() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\tMatrix rrefA = A.rref();\r\n\t\tint rank = A.m;\r\n\t\t\r\n\t\tfor(int i=rrefA.m-1; i>=0; i--) {\r\n\t\t\tif(rrefA.getRowAsVector(i).isZero()) {\r\n\t\t\t\trank--;\t\t\t\r\n\t\t\t} else { \r\n\t\t\t\t// Then we have no more zero rows as rrefA is in reduced row echelon form.\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn rank;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * The rank of a matrix A is the dimension of the vector space spanned by the nullspace of this matrix.\r\n\t * The nullify is always an integer.\r\n\t * \r\n\t * @return Returns the rank of this matrix.\r\n\t */\r\n\t default int nullity() {\r\n\t\tint rank = this.rank();\r\n\t\treturn ((Matrix) this).m - rank;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the matrix inverse if it exists. This is done by first computing the {@link linalg.Decompose#QR(Matrix) QR decomposition}\r\n\t * The inverse of a Matrix A is A<sup>-1</sup> satisfying AA<sup>-1</sup>=I where I is the appropriately sized Identity matrix.\r\n\t * \r\n\t * @return The inverse of this matrix.\r\n\t */\r\n\t default Matrix inverse() {\r\n\t\tMatrix A = (Matrix) this;\r\n\t\t\r\n\t\tif(!A.isSingular()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Matrix is singular.\");\r\n\t\t}\r\n\r\n\t\tMatrix[] QR = Decompose.QR(A); // Compute the QR decomposition of A. This will be used to compute the inverse.\r\n\t\tCNumber detR = CNumber.ONE;\r\n\t\t\r\n\t\tfor(int i = 0; i<QR[1].n; i++) { // Computing the determinant of R\r\n\t\t\tdetR = CNumber.multiply(detR, QR[1].entries[i][i]);\r\n\t\t}\r\n\t\t\r\n\t\tif(CNumber.round(detR, 10).re == 0) {\r\n\t\t\t/* Then we know the matrix is singular.\r\n\t\t\t * We know this by exploiting properties of the orthogonal matrix Q and the upper triangular matrix R.\r\n\t\t\t * The determinant of an orthogonal matrix is either -1 or 1. The determinant of an upper triangular matrix R is the product\r\n\t\t\t * of the diagonals. Since A=QR det(A) = det(QR) = det(Q)*det(R). So if the determinant of R is zero, then the matrix A must be singular.\r\n\t\t\t * \r\n\t\t\t * The isSingular() method is not used here because it computes the QR decomposition to check if the matrix is singular. However, we have already done that, \r\n\t\t\t * so it would be redundant to call the isSingular() method and recompute the QR decomposition again.\r\n\t\t\t */\r\n\t\t\tthrow new IllegalArgumentException(\"Matrix is singular, thus can not be inverted.\");\r\n\t\t}\r\n\t\t\r\n\t\t// Here we compute and return A^-1 = (R^-1)*(Q^-1)\r\n\t\treturn inverseTriU(QR[1]).mult(QR[0].H());\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Computes the matrix inverse if it exists. This is done by first computing the {@link linalg.Decompose#QR(Matrix) QR decomposition}\r\n\t * The inverse of a Matrix A is A<sup>-1</sup> satisfying AA<sup>-1</sup>=I where I is the appropriately sized Identity matrix.\r\n\t * \r\n\t * @return The inverse of this matrix.\r\n\t */\r\n\t default Matrix inv() {\r\n\t\treturn this.inverse();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Helper method to invert an upper triangular matrix. <br>\r\n\t * We can compute the inverse of an n-by-n upper triangular matrix U by solving the n systems...<br><br>\r\n\t * \r\n\t * Ux=I<sub>i</sub><br>\r\n\t * \r\n\t * where 1<=i<=n, I is the n-by-n identity matrix, I<sub>i</sub> is the ith column of I.<br><br>\r\n\t * \r\n\t * Each solution becomes a column in the inverse <sup>-1</sub>.\r\n\t * Because U is upper triangular, we can solve these n systems using backsolve.\r\n\t * \r\n\t * @param U - U is a square upper triangular matrix\r\n\t * @return Returns the inverse of U, denoted U<sup>-1</sub>\r\n\t */\r\n\tstatic Matrix inverseTriU(Matrix U) {\r\n\t\tMatrix Uinv = new Matrix(U.m, U.m);\r\n\t\tMatrix I = Matrix.I(U.m);\r\n\t\t\r\n\t\tif(!U.isTriU()) {\r\n\t\t\tthrow new IllegalArgumentException(\"U must be upper triangular.\");\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<U.m; i++)  {\r\n\t\t\t// U is upper triangular, so to solve the system we simply need to use backsolve function.\r\n\t\t\tUinv.setCol(Solvers.backSolve(U, I.getColAsVector(i)), i); \r\n\t\t}\r\n\t\t\r\n\t\treturn Uinv;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a new matrix that contains the reciprocals of this matrix\r\n\t * \r\n\t * @return new matrix that contains the reciprocals of this matrix\r\n\t */\r\n\t default Matrix recep() {\r\n\t\tMatrix A = new Matrix((Matrix) this).copy();\r\n\t\t\r\n\t\tfor(int i=0; i<A.m; i++) {\r\n\t\t\tfor(int j=0; j<A.n; j++) {\r\n\t\t\t\tA.entries[i][j] = CNumber.inv(A.entries[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn A;\r\n\t}\r\n\t\r\n\t\r\n\t static void main(String[] args) {\r\n\r\n\t\t\r\n\t\tint[][] b = {{1, 3, 3},\r\n\t\t\t\t \t {0, 5, 6},\r\n\t\t\t\t \t {0, 8, 9}};\r\n\t\t\r\n\t\tdouble[][] c = {{ -19.1635403109,        5,               8,               7\t\t},\r\n\t\t\t\t  \t\t{       5,         -19.1635403109,        2,               8\t\t},\r\n\t\t\t\t\t\t{       7,               5,         -15.1635403109,        6\t\t},\r\n\t\t\t\t\t\t{       5,               4,               4,         -13.1635403109 }};\r\n\t\t\r\n\t\tCNumber[][] bc = {{new CNumber(\"2+i\"), new CNumber(\"3\")},\r\n\t\t\t\t  \t\t  {new CNumber(\"1\"), new CNumber(\"-i\")}};\r\n\r\n\t\tMatrix A = new Matrix(bc);\r\n\t\tMatrix B = new Matrix(b);\r\n\t\tMatrix C = new Matrix(c);\r\n\t\t\r\n\t\tMatrix.print(\"C:\\n\", B.sqrt(), \"\\n\\n\");\r\n\t\tMatrix.print(\"C:\\n\", B, \"\\n\\n\");\r\n\r\n\t\tMatrix.print(\"rref:\\n\", A.directSum(B, C), \"\\n\\n\");\r\n\t}\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/linalg/MatrixOperations.java b/src/main/java/linalg/MatrixOperations.java
--- a/src/main/java/linalg/MatrixOperations.java	(revision 411e83e1c424d1d84bb34505365377b4331c89a9)
+++ b/src/main/java/linalg/MatrixOperations.java	(date 1632702163238)
@@ -501,7 +501,7 @@
 		Matrix result = null;
 		
 		if(axis == 0) { // Stack on rows
-			if(A.entries[0].length != B.entries[0].length) { // Ensure matricies have same number or columns
+			if(A.entries[0].length != B.entries[0].length) { // Ensure matrices have same number or columns
 				throw new IllegalArgumentException("Must have same number of columns but "
 						+ "got " + A.entries[0].length + " and " + B.entries[0].length);
 			}
@@ -519,7 +519,7 @@
 			}
 		} 
 		else if(axis == 1) { // Stack on cols
-			if(A.entries.length != B.entries.length) { // Ensure matricies have same number or rows
+			if(A.entries.length != B.entries.length) { // Ensure matrices have same number or rows
 				throw new IllegalArgumentException("Must have same number of rows but "
 						+ "got " + A.entries.length + " and " + B.entries.length);
 			}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ArtifactsWorkspaceSettings\">\r\n    <artifacts-to-build>\r\n      <artifact name=\"Java-Linear-Algebra-v0.0.1-beta:jar\" />\r\n    </artifacts-to-build>\r\n  </component>\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"7072a60c-bdbe-44dc-912a-0b1b7f9f3af3\" name=\"Changes\" comment=\"Add Sonarcloud to project\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MavenRunner\">\r\n    <option name=\"delegateBuildToMaven\" value=\"true\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1yc8grbYeBrYoZturjsTdZ94eiV\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\r\n    <property name=\"project.structure.last.edited\" value=\"Artifacts\" />\r\n    <property name=\"project.structure.proportion\" value=\"0.15280464\" />\r\n    <property name=\"project.structure.side.proportion\" value=\"0.1743421\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"reference.settings.project.maven.runner\" />\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"7072a60c-bdbe-44dc-912a-0b1b7f9f3af3\" name=\"Changes\" comment=\"\" />\r\n      <created>1632539632382</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1632539632382</updated>\r\n      <workItem from=\"1632539633669\" duration=\"66000\" />\r\n      <workItem from=\"1632539702223\" duration=\"1837000\" />\r\n      <workItem from=\"1632541621264\" duration=\"1279000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Add Jar for Release\">\r\n      <created>1632540231649</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1632540231649</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Add Jar for Release\">\r\n      <created>1632540703641</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1632540703641</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Add Sonarcloud to project\">\r\n      <created>1632541488481</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1632541488481</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Add Sonarcloud to project\">\r\n      <created>1632541498618</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1632541498618</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Add Sonarcloud to project\">\r\n      <created>1632541829976</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1632541829976</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Add Jar for Release\" />\r\n    <MESSAGE value=\"Add Sonarcloud to project\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Add Sonarcloud to project\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 411e83e1c424d1d84bb34505365377b4331c89a9)
+++ b/.idea/workspace.xml	(date 1632704283304)
@@ -11,6 +11,7 @@
   <component name="ChangeListManager">
     <list default="true" id="7072a60c-bdbe-44dc-912a-0b1b7f9f3af3" name="Changes" comment="Add Sonarcloud to project">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/linalg/MatrixOperations.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/linalg/MatrixOperations.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -55,6 +56,7 @@
       <workItem from="1632539633669" duration="66000" />
       <workItem from="1632539702223" duration="1837000" />
       <workItem from="1632541621264" duration="1279000" />
+      <workItem from="1632701364868" duration="2013000" />
     </task>
     <task id="LOCAL-00001" summary="Add Jar for Release">
       <created>1632540231649</created>
